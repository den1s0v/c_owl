# relink_acts.ttl
# stage 2  (after alg_rules and before trace_rules)

@prefix  rdf:      <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

# @prefix  rdfs:     <http://www.w3.org/2000/01/rdf-schema#> .
#
# # An important RDF rules subset
# @include <jena/rdfs4core.rules>.
#
#
# @include <jena/loop_names.ttl>.

@prefix my: <http://vstu.ru/poas/code#> .


###############################
# prepare-trace-step
###############################


# redirect end acts from normal ends to interrupted ends
[Redirect-normal-end-to-interrupted-end:
#   acts are linked with consequent
	(?a my:student_next ?b),
	(?a my:executes ?bnd_a),
#	 this link is to be replaced:
	(?b my:executes ?bnd_b),
	(?bnd_b my:end_of ?st_b),
	(?bnd_a my:consequent ?bnd_halt),
#	 a different ending bound (end_of ==> halt_of)
	(?bnd_halt my:halt_of ?st_b),
#	guard for end of global code
	noValue(?bnd_a my:consequent ?bnd_b),
	 ->
	 drop(2),
	 (?b my:executes ?bnd_halt),
]



# executes_id workaround
[executes_id-to-executes-begin:
	(?a my:executes_id ?i),
	(?st my:id ?i),
	(?a rdf:type my:act_begin),
	(?bnd my:begin_of ?st),
	 ->
	 (?a my:executes ?bnd)
]
[executes_id-to-executes-end:
	(?a my:executes_id ?i),
	(?st my:id ?i),
	(?a rdf:type my:act_end),
	(?bnd my:end_of ?st),
	 ->
	 (?a my:executes ?bnd)
]
#	 halt_of is unnesessary here.



###############################
# propagate-skipped-act_ends
###############################


# add obvious end_act(s) next to last correct act (allowing skipping boring end acts)
[Add-act-end-to-prev-to-last-act-if-valid:
#	 this link is to be replaced:
	(?a my:student_next ?b),
	(?a rdf:type my:act_end),
	(?a my:executes ?bnd_a),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st_b),
#   acts aren't linked with consequent
	noValue(?bnd_a my:consequent ?bnd_b),
#   acts are in upcoming chain (i.e. `b` is a valid subsequence)
	(?bnd_u my:boundary_of ?st_b),
	(?bnd_a my:has_upcoming ?bnd_u),
#   corrected bound isn't linked with consequent,
#	so we still need inserting it.
	noValue(?bnd_a my:consequent ?bnd_u),

#   actual consequent of a is M (middle)
	(?bnd_a my:consequent ?bnd_m),
#   bnd_m is `end_of` or `halt_of`
	noValue(?bnd_m, my:begin_of),

#	create a middle act instance
	makeNamedSkolem(?M, my:mid_act_end, ?a, ?bnd_m),

#	make id for new act
	(?a my:id ?a_id),
	sum(?a_id, 1000, ?m_id)
	 ->
	 drop(0),
#	 # reconnect acts via M
	 (?a my:student_next ?M),
	 (?M my:student_next ?b),
	 (?M rdf:type my:act_end),
	 (?M rdf:type my:implicit_act),
	 (?M my:id ?m_id),
	 (?M my:executes ?bnd_m),
#	 # TODO: remove debug print
	 print("-> inject act", ?M, "after", ?a, "executes", ?bnd_m)
]

