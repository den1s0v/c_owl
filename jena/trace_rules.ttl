@prefix  rdf:      <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix  rdfs:     <http://www.w3.org/2000/01/rdf-schema#> .

# An important RDF rules subset
@include <jena/rdfs4core.rules>.


@prefix my: <http://vstu.ru/poas/code#> .



###############################
# trace helper
###############################

# Rule: student_DepthIncr_rule_s6 [helper & mistake]
[student_DepthIncr_rule_s6:
	(?a rdf:type my:act_begin),
	(?a my:student_next ?b),
	(?b rdf:type my:act_begin),
	(?a my:depth ?ad),
	addOne(?ad, ?bd),
	 ->
	 (?a my:student_parent_of ?b),
	 (?b my:depth ?bd),
]

[student_DepthSame_b-e_rule_s7:
	(?a rdf:type my:act_begin),
	(?a my:student_next ?b),
	(?b rdf:type my:act_end),
	(?p my:student_parent_of ?a),
	(?a my:depth ?ad),
	 ->
	(?p my:student_parent_of ?b),
	(?a my:student_corresponding_end ?b),
	(?b my:depth ?ad),
]

[student_DepthSame_e-b_rule_s8:
	(?a rdf:type my:act_end),
	(?a my:student_next ?b),
	(?b rdf:type my:act_begin),
	(?p my:student_parent_of ?a),
	(?a my:depth ?ad),
	 ->
	(?p my:student_parent_of ?b),
	(?b my:depth ?ad),
]

[student_DepthDecr_rule_s9:
	(?a rdf:type my:act_end),
	(?a my:student_next ?b),
	(?b rdf:type my:act_end),
	(?p my:student_parent_of ?a),
	(?a my:depth ?ad),
	difference(?ad, 1, ?bd),
	 ->
	(?p my:student_corresponding_end ?b),
	(?b my:depth ?bd),
]

[student_SameParentOfCorrActs_rule_s10:
	(?a my:student_corresponding_end ?b),
	(?p my:student_parent_of ?a),
	 ->
	 (?p my:student_parent_of ?b)
]

# executes_id workaround
[executes_id-to-executes-begin:
	(?a my:executes_id ?i),
	(?st my:id ?i),
	(?a rdf:type my:act_begin),
	(?bnd my:begin_of ?st),
	 ->
	 (?a my:executes ?bnd)
]
[executes_id-to-executes-end:
	(?a my:executes_id ?i),
	(?st my:id ?i),
	(?a rdf:type my:act_end),
	(?bnd my:end_of ?st),
	 ->
	 (?a my:executes ?bnd)
]


[Erroneous-class-to-wrong_next_act:
	(?b rdf:type my:Erroneous),
	(?a my:student_next ?b),
	 ->
	 (?a my:wrong_next_act ?b)
]


[Reason-4-correct-transition-4-student_next_latest:
# acts are really linked with consequent
	(?a my:student_next_latest ?b),
	(?a my:executes ?bnd_a),
	(?b my:executes ?bnd_b),
	(?bnd_a my:consequent ?bnd_b),

# find leaf reason property (such that has no subproperties)
	(?bnd_a ?p ?bnd_b),
	noValue(?such_p rdfs:subPropertyOf ?p)
	 ->
	 (?b my:reason ?p)
]





###############################
# trace mistake
###############################


# Rule: GenericMisconception_Error [mistake]
[
	(?a my:student_next ?b),
	(?a my:executes ?bx),
	(?b my:executes ?by),
#	prevent match before algorithm is prepared (if this rule is mixed with algorithm processing rules)!
	(?bx my:consequent ?some),
	noValue(?bx my:consequent ?by),
#	print("not a consequent: ",?bx,"--",?by),

	(?bx my:boundary_of ?x),
#	(?by my:boundary_of ?y),
#	Not a choice
	noValue(?x rdf:type my:expr),
#	print("     not an expr: ",?x),
	(?some my:boundary_of ?some_st),
	 ->
	 (?b rdf:type my:WrongNext),
	 (?b my:should_be ?some_st),
	 (?b my:precursor ?a),
]

# Rule: UpcomingNeighbour-Error [mistake]
[
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),
	(?a my:executes ?bx),
	(?b my:executes ?by),
#	check it
	(?bx my:has_upcoming ?by),
	 ->
	 (?b rdf:type my:UpcomingNeighbour),
]

# Rule: UpcomingNeighbour-find-all-missing-Error [mistake]
[
	(?b rdf:type my:UpcomingNeighbour),
	(?a my:student_next ?b),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	(?bx   my:has_upcoming ?some),
	(?some my:has_upcoming ?by),

	(?some my:boundary_of ?some_st),
	(?some_st my:stmt_name ?name),
	 ->
# connecting boundary, not action !
	 (?b my:should_be_after ?some),
	 (?b my:field_MISSING ?name),
]

# Rule: UpcomingNeighbour-find-all-missing-on-1-Error [mistake]
[
	(?b rdf:type my:UpcomingNeighbour),
	(?a my:student_next ?b),

	(?a my:expr_value "true"^^xsd:boolean),

	(?a my:executes ?cnd_e), (?cnd_e my:on_true_consequent ?bx),
	(?b my:executes ?by),
	(?bx   my:has_upcoming ?some),
	(?some my:has_upcoming ?by),

	(?some my:boundary_of ?some_st),
	(?some_st my:stmt_name ?name),
	 ->
# 	 # connecting boundary, not action !
	 (?b my:should_be_after ?some),
	 (?b my:field_MISSING ?name),
]

# Rule: UpcomingNeighbour-find-all-missing-on-0-Error [mistake]
[
	(?b rdf:type my:UpcomingNeighbour),
	(?a my:student_next ?b),

	(?a my:expr_value "false"^^xsd:boolean),

	(?a my:executes ?cnd_e), (?cnd_e my:on_false_consequent ?bx),
	(?b my:executes ?by),
	(?bx   my:has_upcoming ?some),
	(?some my:has_upcoming ?by),

	(?some my:boundary_of ?some_st),
	(?some_st my:stmt_name ?name),
	 ->
# 	 # connecting boundary, not action !
	 (?b my:should_be_after ?some),
	 (?b my:field_MISSING ?name),
]

# Rule: NotNeighbour-not-cond-Error [mistake]
[
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),
	(?a my:executes ?bx),
	(?b my:executes ?by),
#	a is not condition
	(?bx my:always_consequent ?some_bnd),
#	noValue(?a my:type my:expr),
#	check it
	noValue(?bx my:has_upcoming ?by),

	(?by my:boundary_of ?some_st),
	(?some_st my:stmt_name ?name),
	 ->
	 (?b rdf:type my:NotNeighbour),
	 (?b my:field_EXTRA ?name),
]

# Rule: GenericMisconceptionWhenTrue_Error [mistake]
[
	(?a my:student_next ?b),
	(?a my:expr_value "true"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
#	 prevent match before algorithm is prepared!
##	(?bx my:consequent ?some),
	noValue(?bx my:on_true_consequent ?by),

	(?bx my:boundary_of ?x),
#	(?by my:boundary_of ?y),
#	  a choice
	(?x rdf:type my:expr),
	(?bx my:on_true_consequent ?on1),
	(?on1 my:boundary_of ?some_st),
	 ->
	 (?b rdf:type my:WrongNext),
	 (?b my:should_be ?some_st),
	 (?b my:precursor ?a),
]

# Rule: UpcomingNeighbour-whenTrue-Error [mistake]
[
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),
	(?a my:expr_value "true"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	(?bx my:on_true_consequent ?on1),
#	check it
	(?on1 my:has_upcoming ?by),
	 ->
	 (?b rdf:type my:UpcomingNeighbour),
]

# Rule: GenericMisconceptionWhenFalse_Error [mistake]
[
	(?a my:student_next ?b),
	(?a my:expr_value "false"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	noValue(?bx my:on_false_consequent ?by),

	(?bx my:boundary_of ?x),
#	(?by my:boundary_of ?y),
#	  a choice
	(?x rdf:type my:expr),
	(?bx my:on_false_consequent ?on0),
	(?on0 my:boundary_of ?some_st),
	 ->
	 (?b rdf:type my:WrongNext),
	 (?b my:should_be ?some_st),
	 (?b my:precursor ?a),
]

# Rule: UpcomingNeighbour-whenFalse-Error [mistake]
[
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),
	(?a my:expr_value "false"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	(?bx my:on_false_consequent ?on0),
#	check it
	(?on0 my:has_upcoming ?by),
	 ->
	 (?b rdf:type my:UpcomingNeighbour),
]


# Rule: GoFalseWhenTrue_Error [mistake]
[GoFalseWhenTrue_Error:
	(?a my:student_next ?b),
	(?a my:expr_value "true"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
#	immediatly next
	(?bx my:on_false_consequent ?by),
	(?bx my:on_true_consequent ?on1),
	(?on1 my:boundary_of ?some_st),
	 ->
	 (?b rdf:type my:WrongCondNeighbour),
	 (?b my:should_be ?some_st),
	 (?b my:has_causing_condition ?a),
]
# Rule: WrongCondNeighbour-whenTrue-Error [mistake]
[
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),
	(?a my:expr_value "true"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	(?bx my:on_false_consequent ?on0),
	(?bx my:on_true_consequent ?on1),
	(?on1 my:boundary_of ?some_st),
#	check it
#	2+ transitive next
	(?on0 my:has_upcoming ?by),
	 ->
	 (?b rdf:type my:WrongCondNeighbour),
	 (?b my:should_be ?some_st),
	 (?b my:has_causing_condition ?a),
]


# Rule: GoTrueWhenFalse_Error [mistake]
[GoTrueWhenFalse_Error:
	(?a my:student_next ?b),
	(?a my:expr_value "false"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	(?bx my:on_true_consequent ?by),
	(?bx my:on_false_consequent ?on0),
	(?on0 my:boundary_of ?some_st),
	 ->
	 (?b rdf:type my:WrongCondNeighbour),
	 (?b my:should_be ?some_st),
	 (?b my:has_causing_condition ?a),
]
# Rule: WrongCondNeighbour-whenFalse-Error [mistake]
[
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),
	(?a my:expr_value "false"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	(?bx my:on_false_consequent ?on0),
	(?bx my:on_true_consequent ?on1),
	(?on0 my:boundary_of ?some_st),
#	check it
#	2+ transitive next
	(?on1 my:has_upcoming ?by),
	 ->
	 (?b rdf:type my:WrongCondNeighbour),
	 (?b my:should_be ?some_st),
	 (?b my:has_causing_condition ?a),
]

# Rule: WrongCondNeighbour-get-fields [mistake]
[
	(?b rdf:type my:WrongCondNeighbour),
	(?b my:has_causing_condition ?a),

	(?a my:expr_value ?expr_val),
	(?a my:executes ?bx),
	(?bx my:boundary_of ?some_st_a),
	(?some_st_a my:stmt_name ?name_a),

	(?b my:executes ?by),
	(?by my:boundary_of ?some_st),
	(?some_st my:stmt_name ?name),
	 ->
	 (?b my:field_A ?name),
	 (?b my:field_COND ?name_a),
	 (?b my:field_TrueFalse ?expr_val),
]

# Rule: NotNeighbour-cond-Error [mistake]
[
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),
#	(?a my:expr_value ?value___),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	(?bx my:on_false_consequent ?on0),
	(?bx my:on_true_consequent ?on1),
#	check it: not next and not in any "branch"
	noValue(?bx my:consequent ?by),
#	2+ transitive next
	noValue(?on0 my:has_upcoming ?by),
	noValue(?on1 my:has_upcoming ?by),

	(?by my:boundary_of ?some_st),
	(?some_st my:stmt_name ?name),
	 ->
	 (?b rdf:type my:NotNeighbour),
#	 (?b my:precursor ?a),
	 (?b my:field_EXTRA ?name),
]



# Rule: CorrespondingEndMismatched-Error [mistake]
[
	(?a my:student_corresponding_end ?b),
	(?a my:executes ?bnd1),
	(?b my:executes ?bnd2),

	(?bnd1 my:boundary_of ?st1),
	noValue(?bnd2 my:boundary_of ?st1),

	(?bnd2 my:boundary_of ?st2),
	(?st1 my:stmt_name ?a_name),
	(?st2 my:stmt_name ?b_name),
	 ->
	 (?b rdf:type my:CorrespondingEndMismatched),
	 (?b my:cause ?a)
	 (?b my:field_BEGIN ?a_name),
	 (?b my:field_A ?b_name),
]

# Rule: GenericWrongStmtParent_Error [mistake]
[
# 	# limit to begin only
	(?a rdf:type my:act_begin),

	(?p my:student_parent_of ?a),
	(?p my:executes ?bp),
	(?a my:executes ?ba),

	(?bp my:boundary_of ?sp),
	(?ba my:boundary_of ?sa),

	noValue(?sp my:parent_of ?sa),
	(?pa my:parent_of ?sa),

	(?sp my:stmt_name ?p_name),
	(?sa my:stmt_name ?a_name),
	 ->
##	 ??
	 (?a my:cause ?p),
	 (?a my:context_should_be ?pa),
	 (?a rdf:type my:WrongContext),
	 (?a my:field_A ?a_name),
	 (?a my:field_CONTEXT ?p_name),
]

# Rule: OneLevelShallower-Error [mistake]
[
	(?a rdf:type my:WrongContext),
	(?a my:context_should_be ?pa),
	(?p my:student_parent_of ?a),

	(?p my:executes ?bp),
	(?bp my:begin_of ?sp),

	(?sp my:parent_of ?pa),
#	(?pa my:parent_of ?sp),

	(?pa my:stmt_name ?p_name),
	 ->
	 (?a rdf:type my:OneLevelShallower),
	 (?a my:field_PARENT ?p_name),
]

# Rule: EndedDeeper-error [mistake]
[
	(?a rdf:type my:CorrespondingEndMismatched),
	(?b my:student_corresponding_end ?a),
	(?b my:executes ?bb),
	(?a my:executes ?ba),

	(?bb my:boundary_of ?sb),
	(?ba my:boundary_of ?sa),

	(?sa my:hasPartTransitive ?sb),

	(?sa my:stmt_name ?a_name),
	(?sb my:stmt_name ?b_name),
	 ->
#	 (?a my:cause ?b2),
	 (?a rdf:type my:EndedDeeper),
	 (?a my:field_A ?a_name),
	 (?a my:field_INNER ?b_name),
]

# Rule: EndedShallower-error [mistake]
[
	(?a rdf:type my:CorrespondingEndMismatched),
	(?b my:student_corresponding_end ?a),
	(?b my:executes ?bb),
	(?a my:executes ?ba),

	(?bb my:boundary_of ?sb),
	(?ba my:boundary_of ?sa),

	(?sb my:hasPartTransitive ?sa),
	 ->
#	 (?a my:cause ?b2),
	 (?a rdf:type my:EndedShallower)
]










###############################
# sequence mistake
###############################


# Rule: DuplicateOfAct-seq_Error (b,e) [mistake & sequence]
[
#	(?a2 rdf:type my:act_begin),
#	(?a1 rdf:type my:act_begin),
	(?p my:student_parent_of ?a1),
	(?p my:student_parent_of ?a2),

	(?p my:executes ?bb),
	(?bb my:boundary_of ?block),
	(?block rdf:type my:sequence),
	(?block my:body_item ?st),
	(?bnd my:boundary_of ?st),
	(?a1 my:executes ?bnd),
	(?a2 my:executes ?bnd),

		(?a1 my:student_index ?i1),
		(?a2 my:student_index ?i2),
		lessThan(?i1, ?i2),

	(?st my:stmt_name ?a_name),
	(?block my:stmt_name ?p_name),
	 ->
	 (?a2 my:cause ?a1),
	 (?a2 rdf:type my:DuplicateOfAct)
	 (?a2 my:field_A ?a_name),
	 (?a2 my:field_PARENT ?p_name),
]

# Rule: DisplacedAct-Seq_error [mistake & sequence]
# ...

# Rule: NoFirstOfSequence-Seq_error [mistake & sequence]
# (-)

# Rule: TooEarlyInSequence-Seq_error [mistake & sequence]
[TooEarlyInSequence:
	(?b rdf:type my:WrongNext),
	(?b my:should_be ?correct_b),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st_b),

	(?p my:student_parent_of ?b),
	(?p my:executes ?bnd_p), (?bnd_p my:boundary_of ?seq),
	(?seq rdf:type my:sequence),
	(?seq my:body_item ?st_b),
	(?seq my:body_item ?correct_b),
		(?correct_b my:item_index ?index_c),
		(?st_b my:item_index ?index_b),
		lessThan(?index_c, ?index_b),

	(?st_b my:stmt_name ?b_name),
	(?correct_b my:stmt_name ?c_name),
	 ->
	 (?b my:should_be_after ?correct_b),
	 (?b rdf:type my:TooEarlyInSequence),
	 (?b my:field_A ?b_name),
	 (?b my:field_MISSING ?c_name),
]

# Rule: TooLateInSequence-Seq_error [mistake & sequence]
[TooLateInSequence:
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),

	(?p my:student_parent_of ?a),
	(?p my:student_parent_of ?b),
	(?p my:executes ?bnd_p), (?bnd_p my:boundary_of ?seq),
	(?seq rdf:type my:sequence),
	(?seq my:body_item ?st_a),
	(?seq my:body_item ?st_b),

	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?st_a),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st_b),
		(?st_a my:item_index ?index_a),
		(?st_b my:item_index ?index_b),
		greaterThan(?index_a, ?index_b),

	(?st_a my:stmt_name ?a_name),
	(?st_b my:stmt_name ?b_name),
	 ->
	 (?b my:should_be_before ?st_a),
	 (?b rdf:type my:TooLateInSequence)
	 (?b my:field_A ?b_name),
	 (?b my:field_PREVIOUS ?a_name),
]

# [mistake & sequence & helper]
[_FindWhatDoChildrenExecute_Propagate1:
	(?par_b my:gather_child_exec_till ?par_e),
	noValue(?par_e my:gathered_child_exec_till ?par_e),
	(?child1_act my:gathered_child_exec_till ?par_e),
	(?child1_act my:student_next ?child2_act),
	(?par_b my:student_parent_of ?child2_act),
		(?child2_act my:student_index ?i1),
		(?par_e my:student_index ?i2),
		lessThan(?i1, ?i2),
	(?child2_act my:executes ?bound),
	 ->
	 (?par_b my:child_executes ?bound),
	 (?child2_act my:gathered_child_exec_till ?par_e),
]
# [mistake & sequence & helper]
[_FindWhatDoChildrenExecute_Propagate2:
	(?par_b my:gather_child_exec_till ?par_e),
	noValue(?par_e my:gathered_child_exec_till ?par_e),
	(?child1_act my:gathered_child_exec_till ?par_e),
	(?child1_act my:student_corresponding_end ?child2_act),
	(?par_b my:student_parent_of ?child2_act),
		(?child2_act my:student_index ?i1),
		(?par_e my:student_index ?i2),
		lessThan(?i1, ?i2),
	(?child2_act my:executes ?bound),
	 ->
	 (?par_b my:child_executes ?bound),
	 (?child2_act my:gathered_child_exec_till ?par_e),
]
# [mistake & sequence & helper]
[_FindWhatDoChildrenExecute_Finalize:
	(?par_b my:gather_child_exec_till ?par_e),
	noValue(?par_e my:gathered_child_exec_till ?par_e),
	(?child1_act my:gathered_child_exec_till ?par_e),
	(?child1_act my:student_next ?par_e),
	 ->
	 (?par_e my:gathered_child_exec_till ?par_e),
#	 remove gather_child_exec_till
	 drop(0)
]
# [mistake & sequence & helper]
[_FindWhatDoChildrenExecute_Cleanup:
	(?child_act my:gathered_child_exec_till ?par_e),
#	gathering completed
	(?par_b my:gather_child_exec_till ?par_e),
#	do not remove final mark
		(?child_act my:student_index ?i1),
		(?par_e my:student_index ?i2),
		lessThan(?i1, ?i2),
#	print("_FindWhatDoChildrenExecute_Cleanup", ?child_act)
	 ->
#	 remove gathered_child_exec_till
	 drop(0)
]


# Rule: SequenceFinishedTooEarly-init1-Seq_error [mistake & sequence]
[
	(?b rdf:type my:act_end),
	(?b my:executes ?seq_e),
	(?seq_e my:boundary_of ?seq),
	(?seq rdf:type my:sequence),

	(?a my:student_corresponding_end ?b),
	(?a my:student_parent_of ?child_act),
	(?child_act rdf:type my:TooEarlyInSequence),
#	print("SequenceFinishedTooEarly-init1", ?b),
	 ->
#	 find which children acts were executed till the end of seq
	 (?a my:gather_child_exec_till ?b),
]
# Rule: SequenceFinishedTooEarly-init2-Seq_error [mistake & sequence]
[
	(?b rdf:type my:act_end),
	(?b my:executes ?seq_e),
	(?seq_e my:boundary_of ?seq),
	(?seq rdf:type my:sequence),

	(?a my:student_corresponding_end ?b),
	(?b rdf:type my:Erroneous),
#	print("SequenceFinishedTooEarly-init2", ?b),
	 ->
#	 find which children acts were executed till the end of seq
	 (?a my:gather_child_exec_till ?b),
]
# Rule: SequenceFinishedTooEarly-finish-Seq_error [mistake & sequence]
[
	(?b rdf:type my:act_end),
	(?b my:executes ?seq_e), (?seq_e my:boundary_of ?seq),
	(?seq rdf:type my:sequence),

#	check that gathering completed
	(?a my:student_corresponding_end ?b),
	(?b my:gathered_child_exec_till ?b),
#	get a boundary of seq action (that was not executed)
	(?seq my:body_item ?some_st),
##	(?some_st_bnd my:boundary_of ?some_st),
	(?some_st_bnd my:begin_of ?some_st),
#	check that some bounds are not in gathered
	noValue(?a my:child_executes ?some_st_bnd),
#	print("SequenceFinishedTooEarly-finish", ?b),

	(?seq my:stmt_name ?a_name),
	(?some_st my:stmt_name ?b_name),
	 ->
	 (?b my:should_be_after ?some_st),
	 (?b rdf:type my:SequenceFinishedTooEarly),
	 (?b my:field_A ?a_name),
	 (?b my:field_MISSING ?b_name),
]


# Rule: SequenceFinishedNotInOrder-Seq_error [mistake & sequence]
[
	(?b rdf:type my:act_end),
	(?b my:executes ?seq_e), (?seq_e my:boundary_of ?seq),
	(?seq rdf:type my:sequence),

	(?st_b my:consequent ?seq_e),
	(?st_b my:boundary_of ?st),

	(?a my:student_next ?b),

#	# fails because `executes_id -> executes` did not run yet
#	# noValue(?a my:executes ?st_b),
	(?a my:executes ?bnd), (?bnd my:boundary_of ?sa),
		(?st my:id ?id1),
		(?sa my:id ?id2),
		notEqual(?id1, ?id2),

	(?seq my:stmt_name ?a_name),
	 ->

#	print("noValue? ", ?a, " - my:executes - ", ?st_b),
	 (?b my:should_be_after ?st),
	 (?b rdf:type my:SequenceFinishedNotInOrder),
	 (?b my:field_A ?a_name),
]










###############################
# alternative mistake
###############################


# Rule: NoFirstCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_begin),
	(?a my:executes ?bnd), (?bnd my:begin_of ?alt),
	(?alt rdf:type my:alternative),

	(?a my:student_next ?b),
	(?b rdf:type my:WrongNext),
#		(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st_b),
#		(?cnd my:id ?i1),
#		(?st_b my:id ?i2),
#		notEqual(?i1, ?i2),

	(?alt my:branches_item ?br),
	(?br rdf:type my:first_item),
	(?br my:cond ?cnd),

	(?alt my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	 ->
#	 (?b my:precursor ?a),
	 (?b rdf:type my:NoFirstCondition),
	 (?b my:field_ALT ?a_name),
	 (?b my:field_REQUIRED_COND ?c_name),
]

### when different cond used
# Rule: ConditionTooEarly-atAltBegin-alt_Error [alternative & mistake]
[
	(?b rdf:type my:NoFirstCondition),
	(?b my:executes ?bnd), (?bnd my:begin_of ?cnd),

	(?br my:cond ?cnd),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?br my:item_index ?br_i),
	greaterThan(?br_i, 0),

	(?cnd my:stmt_name ?c2_name),
	 ->
#	 (?b my:precursor ?a),
	 (?b rdf:type my:ConditionTooEarly),
	 (?b my:field_CURRENT_ALT_COND ?c2_name),
]

# Rule: BranchOfFalseCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:expr_value "false"^^xsd:boolean),

	(?a my:executes ?bnd), (?bnd my:boundary_of ?cnd),
	(?cnd rdf:type my:expr),

	(?alt_act my:student_parent_of ?a),
	(?alt_act my:student_parent_of ?b),
	(?b rdf:type my:act_begin),

	(?br my:cond ?cnd),
#	(?br rdf:type my:alt_branch),
	(?alt my:branches_item ?br),

	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?br),
#	cond appears before the branch
	(?a my:student_index ?i1),
	(?b my:student_index ?i2),
	lessThan(?i1, ?i2),

	(?alt my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	(?br my:stmt_name ?b_name),
	 ->
	 (?b my:should_be ?alt),
#	 (?b my:precursor ?a),
	 (?b my:cause ?a),
	 (?b rdf:type my:BranchOfFalseCondition),
	 (?b my:field_ALT ?a_name),
	 (?b my:field_LATEST_ALT_COND ?c_name),
	 (?b my:field_UNEXPECTED_BRANCH ?b_name),
]

## Rule: WrongBranch-alt_Error [alternative & mistake]
#[
#	(?a rdf:type my:act_begin),
#	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
#	(?alt my:branches_item ?br),
#	(?alt rdf:type my:alternative),
#
#	(?b rdf:type my:act_begin),
#	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?br2),
#	(?alt my:branches_item ?br2),
#		(?br my:id ?i),
#		(?br2 my:id ?i2),
#		notEqual(?i, ?i2),
## 	основывается на правильной трассе !!
#	(?alt_act my:parent_of ?a),
#	(?alt_act my:student_parent_of ?b),
#	 - > (?b my:should_be ?a),
#	 (?b my:precursor ?a),
#	 (?b rdf:type my:WrongBranch)
#]

# Rule: BranchWithoutCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_begin),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?b my:student_next ?a),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st),

	(?br my:cond ?cnd),

		(?st my:id ?i),
		(?cnd my:id ?i2),
		notEqual(?i, ?i2),

	(?alt my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	(?br my:stmt_name ?b_name),
	 ->
	 (?a my:should_be_after ?cnd),
	 (?a my:precursor ?b),
	 (?a my:context_should_be ?alt),
	 (?a rdf:type my:BranchWithoutCondition),
	 (?a my:field_ALT ?a_name),
	 (?a my:field_REQUIRED_COND ?c_name),
	 (?a my:field_UNEXPECTED_BRANCH ?b_name),
]

# Rule: BranchNotNextToCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:BranchWithoutCondition),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
	(?br my:cond ?cnd),

	(?alt_act my:student_parent_of ?a),
	(?c my:executes ?bnd_b), (?bnd_b my:boundary_of ?cnd),
	(?a my:in_trace ?trace),
	(?c my:in_trace ?trace),
#	^ можно переделать на student_parent_of ??

		(?alt_act my:student_index ?ia),
		(?c my:student_index ?ic),
		lessThan(?ia, ?ic),

		(?a my:student_index ?ib),
		lessThan(?ic, ?ib),
	 ->
	 (?a rdf:type my:BranchNotNextToCondition),
]

# Rule: ElseBranchNotNextToLastCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_begin),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
	(?br rdf:type my:else),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?b my:student_next ?a),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st),

	(?br1 my:next ?br),
	(?br1 my:cond ?cnd),

		(?st my:id ?i),
		(?cnd my:id ?i2),
		notEqual(?i, ?i2),
	(?alt my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	 ->
	 (?a my:should_be_after ?cnd),
	 (?a my:precursor ?b),
	 (?a my:context_should_be ?alt),
	 (?a rdf:type my:ElseBranchNotNextToLastCondition),
	 (?a my:field_ALT ?a_name),
	 (?a my:field_REQUIRED_COND ?c_name),
]

## Rule: ElseBranchAfterTrueCondition-alt_Error [alternative & mistake]
#[
#	(?a rdf:type my:act_begin),
#	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
#	(?br rdf:type my:else),
#	(?alt my:branches_item ?br),
#	(?alt rdf:type my:alternative),
#
#	(?br1 my:next ?br),
#	(?br1 my:cond ?cnd),
#
#	(?b my:student_next ?a),
#	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?cnd),
#
#	(?b my:expr_value "true"^^xsd:boolean),
#
#	(?alt my:stmt_name ?a_name),
#	(?cnd my:stmt_name ?c_name),
#	 ->
#	 (?a my:should_be_after ?cnd),
#	 (?a my:precursor ?b),
#	 (?a my:context_should_be ?alt),
#	 (?a rdf:type my:ElseBranchAfterTrueCondition),
#	 (?a my:field_ALT ?a_name),
#	 (?a my:field_LATEST_ALT_COND ?c_name),
#]

# Rule: ElseBranchAfterTrueCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_begin),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
	(?br rdf:type my:else),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?br1 my:next ?br),
	(?br1 my:cond ?cnd),

	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?cnd),
	(?b my:expr_value "true"^^xsd:boolean),

#	# not only next
#	(?b my:student_next ?a),

	(?alt_act my:student_parent_of ?a),
	(?alt_act my:executes ?bnd_alt), (?bnd_alt my:boundary_of ?alt),

	(?alt_act my:student_index ?alt_i),
	(?b my:student_index ?b_i),
	lessThan(?alt_i, ?b_i),

	(?a my:student_index ?a_i),
	lessThan(?b_i, ?a_i),

	(?alt my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	 ->
	 (?a my:should_be_after ?cnd),
	 (?a my:precursor ?b),
	 (?a my:context_should_be ?alt),
	 (?a rdf:type my:ElseBranchAfterTrueCondition),
	 (?a my:field_ALT ?a_name),
	 (?a my:field_LATEST_ALT_COND ?c_name),
]

# Rule: CondtionNotNextToPrevCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_begin),
	(?alt my:branches_item ?br2),
	(?alt rdf:type my:alternative),
	(?br2 my:cond ?cnd2),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd2),

	(?b my:student_next ?a),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st),

	(?br1 my:next ?br2),
	(?br1 my:cond ?cnd1),

		(?st my:id ?i),
		(?cnd1 my:id ?i2),
		notEqual(?i, ?i2),
	(?alt my:stmt_name ?a_name),
	(?cnd1 my:stmt_name ?c_name),
	(?cnd2 my:stmt_name ?c2_name),
	 ->
	 (?a my:should_be_after ?cnd1),
	 (?a my:precursor ?b),
	 (?a my:context_should_be ?alt),
	 (?a rdf:type my:CondtionNotNextToPrevCondition),
	 (?a my:field_ALT ?a_name),
	 (?a my:field_REQUIRED_COND ?c_name),
	 (?a my:field_CURRENT_ALT_COND ?c2_name),
]

#	specify ^ as 2: the condition is too early/too late
# Rule: ConditionTooEarly-afterCond-alt_Error [alternative & mistake]
[
	(?a rdf:type my:CondtionNotNextToPrevCondition),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd2),
	(?br2 my:cond ?cnd2),
	(?alt my:branches_item ?br2),
	(?alt rdf:type my:alternative),

	(?b my:student_next ?a),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?cnd1),
	(?br1 my:cond ?cnd1),
	(?alt my:branches_item ?br1),

	(?br1 my:item_index ?br1_i),
	(?br2 my:item_index ?br2_i),
	greaterThan(?br2_i, ?br1_i),
	 ->
#	 (?a my:precursor ?b),
	 (?a rdf:type my:ConditionTooEarly),
]
# Rule: ConditionTooLate-alt_Error [alternative & mistake]
[
	(?a rdf:type my:CondtionNotNextToPrevCondition),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd2),
	(?br2 my:cond ?cnd2),
	(?alt my:branches_item ?br2),
	(?alt rdf:type my:alternative),

	(?b my:student_next ?a),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?cnd1),
	(?br1 my:cond ?cnd1),
	(?alt my:branches_item ?br1),

	(?br1 my:item_index ?br1_i),
	(?br2 my:item_index ?br2_i),
	lessThan(?br2_i, ?br1_i),
	 ->
#	 (?a my:precursor ?b),
	 (?a rdf:type my:ConditionTooLate),
]
# Rule: DuplicateOfCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:CondtionNotNextToPrevCondition),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd),
	(?br2 my:cond ?cnd),
	(?alt my:branches_item ?br2),
	(?alt rdf:type my:alternative),
#	not just in next alt act (ensure both are within same alt act)
	(?p my:student_parent_of ?a),
	(?p my:student_parent_of ?b),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?cnd),
#	later act only
	(?b my:student_index ?i1),
	(?a my:student_index ?i2),
	lessThan(?i1, ?i2),

	(?alt my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	 ->
#	 (?a my:precursor ?b),
	 (?a rdf:type my:DuplicateOfCondition),
#	 # were set by CondtionNotNextToPrevCondition >>
	 (?a my:field_ALT ?a_name),
	 (?a my:field_CURRENT_ALT_COND ?c_name),
]

# Rule: ConditionAfterBranch-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?a my:student_next ?b),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?cnd),
	(?cnd rdf:type my:expr),

	(?alt my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	(?br my:stmt_name ?b_name),
	 ->
	 (?b my:should_be ?alt),
#	 (?b my:precursor ?a),
	 (?b rdf:type my:ConditionAfterBranch),
	 (?b my:field_ALT ?a_name),
	 (?b my:field_UNEXPECTED_ALT_COND ?c_name),
	 (?b my:field_BRANCH ?b_name),
]

# Rule: AnotherExtraBranch-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_begin),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?b rdf:type my:act_begin),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?br2),
	(?alt my:branches_item ?br2),

	(?alt_act my:student_parent_of ?a),
	(?alt_act my:student_parent_of ?b),

	(?a my:student_index ?sia),
	(?b my:student_index ?sib),
	greaterThan(?sib, ?sia),

	(?alt my:stmt_name ?a_name),
	(?br my:stmt_name ?b_name),
	(?br2 my:stmt_name ?b2_name),
	 ->
	 (?b my:cause ?a),
	 (?b rdf:type my:AnotherExtraBranch),
	 (?b my:field_ALT ?a_name),
	 (?b my:field_BRANCH ?b_name),
	 (?b my:field_UNEXPECTED_BRANCH ?b2_name),
]

# Rule: NoBranchWhenConditionIsTrue-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd),
	(?cnd rdf:type my:expr),

	(?a my:expr_value "true"^^xsd:boolean),

	(?br my:cond ?cnd),
	(?br rdf:type my:alt_branch),
	(?alt my:branches_item ?br),

	(?a my:student_next ?b),
#	(?b rdf:type my:WrongNext),
	(?b my:executes ?bnd_b),
	noValue(?bnd_b my:boundary_of ?br),
#		(?st my:id ?i),
#		(?br my:id ?i2),
#		notEqual(?i, ?i2),

	(?alt my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	(?br my:stmt_name ?b_name),
	 ->
	 (?b my:should_be ?br),
#	 (?b my:precursor ?a),
	 (?b rdf:type my:NoBranchWhenConditionIsTrue),
	 (?b my:field_ALT ?a_name),
	 (?b my:field_LATEST_ALT_COND ?c_name),
	 (?b my:field_EXPECTED_BRANCH ?b_name),
]

# Rule: LastConditionIsFalseButNoElse-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd),
	(?cnd rdf:type my:expr),
	(?a my:expr_value "false"^^xsd:boolean),

	(?br my:cond ?cnd),
	(?alt my:branches_item ?br),
	(?br my:next ?br2),
	(?br2 rdf:type my:else),

	(?a my:student_next ?b),
	(?b rdf:type my:WrongNext),
#	(?b my:executes ?st),
#		(?st my:id ?i),
#		(?br2 my:id ?i2),
#		notEqual(?i, ?i2),

	(?alt my:stmt_name ?a_name),
	 ->
	 (?b my:should_be ?br2),
#	 (?b my:precursor ?a),
	 (?b rdf:type my:LastConditionIsFalseButNoElse),
	 (?b my:field_ALT ?a_name),
]

# Rule: LastConditionIsFalseButNoElse-helper-alt_Error [alternative & mistake]
[
	(?b rdf:type my:LastConditionIsFalseButNoElse),
	(?b my:should_be ?br2),
	(?alt my:branches_item ?br2),
#	# get any branch of this alt
	(?alt my:branches_item ?br),
	(?br my:cond ?cnd),

	(?cnd my:stmt_name ?c_name),
	 ->
	 (?b my:field_ALT_COND ?c_name),
]


# Rule: NoNextCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd),
	(?cnd rdf:type my:expr),

	(?a my:expr_value "false"^^xsd:boolean),
	(?br my:cond ?cnd),
	(?br my:next ?br2),
	(?br2 my:cond ?cnd2),

	(?a my:student_next ?b),
	(?b rdf:type my:WrongNext),

#	(?b my:executes ?st),
#		(?st my:id ?i),
#		(?cnd2 my:id ?i2),
#		notEqual(?i, ?i2),

	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),
	(?alt my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	(?cnd2 my:stmt_name ?c2_name),
	 ->
	 (?b my:should_be ?cnd2),
#	 (?b my:precursor ?a),
	 (?b rdf:type my:NoNextCondition),
	 (?b my:field_ALT ?a_name),
	 (?b my:field_LATEST_ALT_COND ?c_name),
	 (?b my:field_EXPECTED_ALT_COND ?c2_name),
]

# Rule: LastFalseNoEnd-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_end),
	(?cnd rdf:type my:expr),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd),

	(?a my:expr_value "false"^^xsd:boolean),
	(?br my:cond ?cnd),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),
	(?br rdf:type my:last_item),

	(?a my:student_next ?b),
	(?b rdf:type my:WrongNext),
#	(?b my:executes ?st),
#		(?st my:id ?i),
#		(?alt my:id ?i2),
#		notEqual(?i, ?i2),
	(?alt my:stmt_name ?a_name),
	 ->
	 (?b my:precursor ?a),
	 (?b my:should_be ?alt),
	 (?b rdf:type my:LastFalseNoEnd),
	 (?b my:field_ALT ?a_name),
]

# Rule: LastFalseNoEnd-helper-alt_Error [alternative & mistake]
[
	(?b rdf:type my:LastFalseNoEnd),
	(?b my:should_be ?alt),
#	# get any branch of this alt
	(?alt my:branches_item ?br),
	(?br my:cond ?cnd),

	(?cnd my:stmt_name ?c_name),
	 ->
	 (?b my:field_ALT_COND ?c_name),
]

# Rule: NoAlternativeEndAfterBranch-alt_Error [alternative & mistake]
[

	(?a rdf:type my:act_end),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?a my:student_next ?b),
	(?b rdf:type my:WrongNext),
#	(?b my:executes ?st),
#		(?st my:id ?i),
#		(?alt my:id ?i2),
#		notEqual(?i, ?i2),

	(?alt my:stmt_name ?a_name),
	(?br my:stmt_name ?b_name),
	 ->
	 (?b my:should_be ?alt),
#	 (?b my:precursor ?a),
	 (?b rdf:type my:NoAlternativeEndAfterBranch),
	 (?b my:field_ALT ?a_name),
	 (?b my:field_BRANCH ?b_name),
]

# Rule: AlternativeEndAfterTrueCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:expr_value "true"^^xsd:boolean),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd),
	(?br my:cond ?cnd),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?a my:student_next ?b),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?alt),

	(?alt my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	 ->
	 (?b my:should_be ?br),
	 (?b my:precursor ?a),
	 (?b rdf:type my:AlternativeEndAfterTrueCondition)
	 (?b my:field_ALT ?a_name),
	 (?b my:field_LATEST_ALT_COND ?c_name),
]








###############################
# loop mistake
###############################

# Rule: fetch_kind_of_loop-helper [loop & mistake]
[
	(?a my:fetch_kind_of_loop ?Loop),
	(?Loop rdf:type my:while_loop),
	 ->
	 drop(0),
	 (?a my:field_kind_of_loop "WHILE"),
]
# Rule: fetch_kind_of_loop-helper [loop & mistake]
[
	(?a my:fetch_kind_of_loop ?Loop),
	(?Loop rdf:type my:do_while_loop),
	 ->
	 drop(0),
	 (?a my:field_kind_of_loop "DO-WHILE"),
]
# TODO: ... add more helper rules for other kinds of loops:
#	for_loop
#	foreach_loop

# Rule: LoopStartIsNotCondition-loop_Error [loop & mistake]
[
	(?a rdf:type my:act_begin),
	(?a my:executes ?bnd), (?bnd my:boundary_of ?Loop),
	(?Loop rdf:type my:start_with_cond),
	(?Loop my:cond ?cnd),

	(?a my:student_next ?b),
	(?b my:executes ?bnd_b),
#	not loop end
	noValue(?bnd_b my:end_of ?Loop),
#	not loop's cond
	noValue(?bnd_b my:begin_of ?cnd),

	(?Loop my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	 ->
#	 (?b my:cause ?a),
	 (?b rdf:type my:LoopStartIsNotCondition),
	 (?b my:field_LOOP ?a_name),
	 (?b my:field_LOOP_COND ?c_name),
	 (?b my:fetch_kind_of_loop ?Loop),
]

# Rule: LoopStartIsNotIteration-loop_Error [loop & mistake]
[
	(?a rdf:type my:act_begin),
	(?a my:executes ?bnd), (?bnd my:boundary_of ?Loop),
	(?Loop rdf:type my:start_with_body),
	(?Loop my:body ?Body),

	(?a my:student_next ?b),
	(?b my:executes ?bnd_b),
#	not loop end
	noValue(?bnd_b my:boundary_of ?Loop),
#	not loop's body
	noValue(?bnd_b my:boundary_of ?Body),

	(?Loop my:stmt_name ?a_name),
	 ->
#	 (?b my:cause ?a),
	 (?b rdf:type my:LoopStartIsNotIteration),
	 (?b my:field_LOOP ?a_name),
]

# Rule: NoIterationAfterSuccessfulCondition-1-loop_Error [loop & mistake]
[NoIterationAfterSuccessfulCondition-1-loop_Error:
	(?a rdf:type my:act_end),
	(?a my:executes ?bnd), (?bnd my:boundary_of ?cnd),
	(?Loop my:cond ?cnd),
	(?Loop rdf:type my:cond_then_body),

	(?a my:expr_value "true"^^xsd:boolean),

	(?a my:student_next ?b),
	(?Loop my:body ?Body),
	(?b my:executes ?bnd_b),
	noValue(?bnd_b my:boundary_of ?Body),

	(?Loop my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	 ->
	 (?b rdf:type my:NoIterationAfterSuccessfulCondition)
	 (?b my:field_LOOP ?a_name),
	 (?b my:field_LOOP_COND ?c_name),
	 (?b my:fetch_kind_of_loop ?Loop),
]

# Rule: LoopEndAfterSuccessfulCondition-1-loop_Error [loop & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:executes ?bnd), (?bnd my:boundary_of ?cnd),
	(?Loop my:cond ?cnd),
	(?Loop rdf:type my:cond_then_body),

	(?a my:expr_value "true"^^xsd:boolean),

	(?a my:student_next ?b),
	(?b my:executes ?bnd_b),
	(?bnd_b my:end_of ?Loop),

	(?Loop my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	 ->
#	 (?b my:cause ?a),
	 (?b rdf:type my:LoopEndAfterSuccessfulCondition),
	 (?b my:field_LOOP ?a_name),
	 (?b my:field_LOOP_COND ?c_name),
	 (?b my:fetch_kind_of_loop ?Loop),
]

# Rule: NoIterationAfterSuccessfulCondition-0-loop_Error [loop & mistake]
# ...

# Rule: NoLoopEndAfterFailedCondition-0-loop_Error [loop & mistake]
[
	(?a rdf:type my:act_end),
	(?Loop rdf:type my:loop),
	(?Loop my:cond ?cnd),
	(?a my:executes ?bnd), (?bnd my:boundary_of ?cnd),

	(?a my:expr_value "false"^^xsd:boolean),

	(?a my:student_next ?b),
	(?b rdf:type my:WrongNext),

	(?Loop my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	 ->
#	 (?b my:cause ?a),
	 (?b rdf:type my:NoLoopEndAfterFailedCondition)
	 (?b my:field_LOOP ?a_name),
	 (?b my:field_LOOP_COND ?c_name),
	 (?b my:fetch_kind_of_loop ?Loop),
]

# Rule: LoopEndsWithoutCondition-loop_Error [loop & mistake]
[
	(?b rdf:type my:act_end),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?Loop),
	(?Loop rdf:type my:conditional_loop),

	(?a my:student_next ?b),
#	(?b rdf:type my:Erroneous),
	(?Loop my:cond ?cnd),
	(?a my:executes ?bnd_a),
	noValue(?bnd_a my:boundary_of ?cnd),

	(?Loop my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	 ->
	 (?b my:field_LOOP ?a_name),
	 (?b my:field_LOOP_COND ?c_name),
	 (?b rdf:type my:LoopEndsWithoutCondition)
]

# Rule: LoopContinuedAfterFailedCondition-loop_Error [loop & mistake]
[
	(?b rdf:type my:NoLoopEndAfterFailedCondition),
	(?b rdf:type my:ConditionMisuse),
	 -> (?b rdf:type my:LoopContinuedAfterFailedCondition)
#	 # fields are inherited
]

# Rule: IterationAfterFailedCondition-loop_Error [loop & mistake]
[
	(?b rdf:type my:NoLoopEndAfterFailedCondition),
	(?b rdf:type my:act_begin),
	(?b my:executes ?bnd), (?bnd my:boundary_of ?st),
	(?L my:body ?st),
	(?L rdf:type my:cond_then_body),
	 -> (?b rdf:type my:IterationAfterFailedCondition)
#	 # fields are inherited
]

# Rule: NoConditionAfterIteration-loop_Error [loop & mistake]
[
	(?a rdf:type my:act_end),
	(?Loop rdf:type my:body_then_cond),
	(?Loop my:body ?st),
	(?a my:executes ?bnd), (?bnd my:boundary_of ?st),
	(?Loop my:cond ?cnd),

	(?a my:student_next ?b),
	(?b my:executes ?bnd_b),
	noValue(?bnd_b my:boundary_of ?cnd),

	(?Loop my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	 ->
	 (?b rdf:type my:NoConditionAfterIteration)
	 (?b my:field_LOOP ?a_name),
	 (?b my:field_LOOP_COND ?c_name),
	 (?b my:fetch_kind_of_loop ?Loop),
]

# Rule: NoConditionBetweenIterations-loop_Error [loop & mistake]
[
	(?a rdf:type my:act_end),
	(?Loop rdf:type my:body_then_cond),
	(?Loop my:body ?st),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?st),

	(?a my:student_next ?b),
	(?b rdf:type my:act_begin),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st),
#	страховка >
#	(?b rdf:type my:Erroneous),
	(?Loop my:cond ?cnd),

	(?Loop my:stmt_name ?a_name),
	(?cnd my:stmt_name ?c_name),
	 ->
	 (?b my:should_be_after ?cnd),
	 (?b rdf:type my:NoConditionBetweenIterations)
	 (?b my:field_LOOP ?a_name),
	 (?b my:field_LOOP_COND ?c_name),
	 (?b my:fetch_kind_of_loop ?Loop),
]


