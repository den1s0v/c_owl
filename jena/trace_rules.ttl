@prefix  rdf:      <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix  rdfs:     <http://www.w3.org/2000/01/rdf-schema#> .

# An important RDF rules subset
@include <jena/rdfs4core.rules>.


@prefix my: <http://vstu.ru/poas/code#> .



###############################
# trace helper
###############################

# Rule: student_DepthIncr_rule_s6 [helper & mistake]
[student_DepthIncr_rule_s6:
	(?a rdf:type my:act_begin),
	(?a my:student_next ?b),
	(?b rdf:type my:act_begin),
	(?a my:depth ?ad),
	addOne(?ad, ?bd),
	 ->
	 (?a my:student_parent_of ?b),
	 (?b my:depth ?bd),
]

[student_DepthSame_b-e_rule_s7:
	(?a rdf:type my:act_begin),
	(?a my:student_next ?b),
	(?b rdf:type my:act_end),
	(?p my:student_parent_of ?a),
	(?a my:depth ?ad),
	 ->
	(?p my:student_parent_of ?b),
	(?a my:student_corresponding_end ?b),
	(?b my:depth ?ad),
]

[student_DepthSame_e-b_rule_s8:
	(?a rdf:type my:act_end),
	(?a my:student_next ?b),
	(?b rdf:type my:act_begin),
	(?p my:student_parent_of ?a),
	(?a my:depth ?ad),
	 ->
	(?p my:student_parent_of ?b),
	(?b my:depth ?ad),
]

[student_DepthDecr_rule_s9:
	(?a rdf:type my:act_end),
	(?a my:student_next ?b),
	(?b rdf:type my:act_end),
	(?p my:student_parent_of ?a),
	(?a my:depth ?ad),
	difference(?ad, 1, ?bd),
	 ->
	(?p my:student_corresponding_end ?b),
	(?b my:depth ?bd),
]

[student_SameParentOfCorrActs_rule_s10:
	(?a my:student_corresponding_end ?b),
	(?p my:student_parent_of ?a),
	 ->
	 (?p my:student_parent_of ?b)
]

# executes_id workaround
[executes_id-to-executes-begin:
	(?a my:executes_id ?i),
	(?st my:id ?i),
	(?a rdf:type my:act_begin),
	(?bnd my:begin_of ?st),
	 ->
	 (?a my:executes ?bnd)
]
[executes_id-to-executes-end:
	(?a my:executes_id ?i),
	(?st my:id ?i),
	(?a rdf:type my:act_end),
	(?bnd my:end_of ?st),
	 ->
	 (?a my:executes ?bnd)
]






###############################
# trace mistake
###############################


# Rule: GenericMisconception_Error [mistake]
[
	(?a my:student_next ?b),
	(?a my:executes ?bx),
	(?b my:executes ?by),
#	prevent match before algorithm is prepared (if this rule is mixed with algorithm processing rules)!
	(?bx my:consequent ?some),
	noValue(?bx my:consequent ?by),
#	print("not a consequent: ",?bx,"--",?by),

	(?bx my:boundary_of ?x),
#	(?by my:boundary_of ?y),
#	Not a choice
	noValue(?x rdf:type my:expr),
#	print("     not an expr: ",?x),
	(?some my:boundary_of ?some_st),
	 ->
	 (?b rdf:type my:WrongNext),
	 (?b my:should_be ?some_st),
	 (?b my:precursor ?a),
]

# Rule: UpcomingNeighbour-Error [mistake]
[
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),
	(?a my:executes ?bx),
	(?b my:executes ?by),
#	check it
	(?bx my:has_upcoming ?by),
	 ->
	 (?b rdf:type my:UpcomingNeighbour),
]

# Rule: UpcomingNeighbour-find-all-missing-Error [mistake]
[
	 (?b rdf:type my:UpcomingNeighbour),
	(?a my:student_next ?b),
	(?a my:executes ?bx),
	(?b my:executes ?by),
#	prevent match before algorithm is prepared (if this rule is mixed with algorithm processing rules)!
	(?bx   my:has_upcoming ?some),
	(?some my:has_upcoming ?by),
	 ->
# connecting boundary, not action !
	 (?b my:should_be_after ?some),
]

# Rule: NotNeighbour-not-cond-Error [mistake]
[
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),
	(?a my:executes ?bx),
	(?b my:executes ?by),
#	a is not condition
	(?bx my:always_consequent ?some_bnd),
#	noValue(?a my:type my:expr),
#	check it
	noValue(?bx my:has_upcoming ?by),
	 ->
	 (?b rdf:type my:NotNeighbour),
]

# Rule: GenericMisconceptionWhenTrue_Error [mistake]
[
	(?a my:student_next ?b),
	(?a my:expr_value "true"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
#	 prevent match before algorithm is prepared!
##	(?bx my:consequent ?some),
	noValue(?bx my:consequent ?by),

	(?bx my:boundary_of ?x),
#	(?by my:boundary_of ?y),
#	  a choice
	(?x rdf:type my:expr),
	(?bx my:on_true_consequent ?on1),
	(?on1 my:boundary_of ?some_st),
	 ->
	 (?b rdf:type my:WrongNext),
	 (?b my:should_be ?some_st),
	 (?b my:precursor ?a),
]

# Rule: UpcomingNeighbour-whenTrue-Error [mistake]
[
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),
	(?a my:expr_value "true"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	(?bx my:on_true_consequent ?on1),
#	check it
	(?on1 my:has_upcoming ?by),
	 ->
	 (?b rdf:type my:UpcomingNeighbour),
]

# Rule: GenericMisconceptionWhenFalse_Error [mistake]
[
	(?a my:student_next ?b),
	(?a my:expr_value "false"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	noValue(?bx my:consequent ?by),

	(?bx my:boundary_of ?x),
#	(?by my:boundary_of ?y),
#	  a choice
	(?x rdf:type my:expr),
	(?bx my:on_false_consequent ?on0),
	(?on0 my:boundary_of ?some_st),
	 ->
	 (?b rdf:type my:WrongNext),
	 (?b my:should_be ?some_st),
	 (?b my:precursor ?a),
]

# Rule: UpcomingNeighbour-whenFalse-Error [mistake]
[
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),
	(?a my:expr_value "false"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	(?bx my:on_false_consequent ?on0),
#	check it
	(?on0 my:has_upcoming ?by),
	 ->
	 (?b rdf:type my:UpcomingNeighbour),
]


# Rule: GoFalseWhenTrue_Error [mistake]
[GoFalseWhenTrue_Error:
	(?a my:student_next ?b),
	(?a my:expr_value "true"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
#	immediatly next
	(?bx my:on_false_consequent ?by),
	(?bx my:on_true_consequent ?on1),
	(?on1 my:boundary_of ?some_st),
	 ->
	 (?b rdf:type my:WrongCondNeighbour),
	 (?b my:should_be ?some_st),
	 (?b my:has_causing_condition ?a),
]
# Rule: WrongCondNeighbour-whenTrue-Error [mistake]
[
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),
	(?a my:expr_value "true"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	(?bx my:on_false_consequent ?on0),
	(?bx my:on_true_consequent ?on1),
	(?on1 my:boundary_of ?some_st),
#	check it
#	2+ transitive next
	(?on0 my:has_upcoming ?by),
	 ->
	 (?b rdf:type my:WrongCondNeighbour),
	 (?b my:should_be ?some_st),
	 (?b my:has_causing_condition ?a),
]


# Rule: GoTrueWhenFalse_Error [mistake]
[GoTrueWhenFalse_Error:
	(?a my:student_next ?b),
	(?a my:expr_value "false"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	(?bx my:on_true_consequent ?by),
	(?bx my:on_false_consequent ?on0),
	(?on0 my:boundary_of ?some_st),
	 ->
	 (?b rdf:type my:WrongCondNeighbour),
	 (?b my:should_be ?some_st),
	 (?b my:has_causing_condition ?a),
]
# Rule: WrongCondNeighbour-whenFalse-Error [mistake]
[
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),
	(?a my:expr_value "false"^^xsd:boolean),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	(?bx my:on_false_consequent ?on0),
	(?bx my:on_true_consequent ?on1),
	(?on0 my:boundary_of ?some_st),
#	check it
#	2+ transitive next
	(?on1 my:has_upcoming ?by),
	 ->
	 (?b rdf:type my:WrongCondNeighbour),
	 (?b my:should_be ?some_st),
	 (?b my:has_causing_condition ?a),
]

# Rule: NotNeighbour-cond-Error [mistake]
[
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),
#	(?a my:expr_value ?value___),
	(?a my:executes ?bx),
	(?b my:executes ?by),
	(?bx my:on_false_consequent ?on0),
	(?bx my:on_true_consequent ?on1),
#	check it: not next and not in any "branch"
	noValue(?bx my:consequent ?by),
#	2+ transitive next
	noValue(?on0 my:has_upcoming ?by),
	noValue(?on1 my:has_upcoming ?by),
	 ->
	 (?b rdf:type my:NotNeighbour),
#	 (?b my:precursor ?a),
]



# Rule: CorrespondingEndMismatched-Error [mistake]
[
	(?a my:student_corresponding_end ?b),
	(?a my:executes ?s1),
	(?b my:executes ?s2),

	(?s1 my:boundary_of ?st),
	noValue(?s2 my:boundary_of ?st),
	 ->
	 (?b rdf:type my:CorrespondingEndMismatched),
	 (?b my:cause ?a)
]

# Rule: GenericWrongStmtParent_Error [mistake]
[
	(?p my:student_parent_of ?a),
	(?p my:executes ?bp),
	(?a my:executes ?ba),

	(?bp my:boundary_of ?sp),
	(?ba my:boundary_of ?sa),

	noValue(?sp my:parent_of ?sa),
	(?pa my:parent_of ?sa),
	 ->
##	 ??
	 (?a my:cause ?p),
	 (?a my:context_should_be ?pa),
	 (?a rdf:type my:WrongContext)
]

# Rule: OneLevelShallower-Error [mistake]
[
	(?a rdf:type my:WrongContext),
	(?a my:context_should_be ?pa),
	(?p my:student_parent_of ?a),

	(?p my:executes ?bp),
	(?bp my:begin_of ?sp),

	(?sp my:parent_of ?pa),
#	(?pa my:parent_of ?sp),
	 ->
	 (?a rdf:type my:OneLevelShallower)
]

# Rule: EndedDeeper-error [mistake]
[
	(?a rdf:type my:CorrespondingEndMismatched),
	(?b my:student_corresponding_end ?a),
	(?b my:executes ?bb),
	(?a my:executes ?ba),

	(?bb my:boundary_of ?sb),
	(?ba my:boundary_of ?sa),

	(?sa my:hasPartTransitive ?sb),
	 ->
#	 (?a my:cause ?b2),
	 (?a rdf:type my:EndedDeeper)
]

# Rule: EndedShallower-error [mistake]
[
	(?a rdf:type my:CorrespondingEndMismatched),
	(?b my:student_corresponding_end ?a),
	(?b my:executes ?bb),
	(?a my:executes ?ba),

	(?bb my:boundary_of ?sb),
	(?ba my:boundary_of ?sa),

	(?sb my:hasPartTransitive ?sa),
	 ->
#	 (?a my:cause ?b2),
	 (?a rdf:type my:EndedShallower)
]










###############################
# sequence mistake
###############################


# Rule: DuplicateOfAct-seq_Error (b,e) [mistake & sequence]
[
#	(?a2 rdf:type my:act_begin),
#	(?a1 rdf:type my:act_begin),
	(?p my:student_parent_of ?a1),
	(?p my:student_parent_of ?a2),

	(?p my:executes ?bb),
	(?bb my:boundary_of ?block),
	(?block rdf:type my:sequence),
	(?block my:body_item ?st),
	(?bnd my:boundary_of ?st),
	(?a1 my:executes ?bnd),
	(?a2 my:executes ?bnd),

		(?a1 my:student_index ?i1),
		(?a2 my:student_index ?i2),
		lessThan(?i1, ?i2),
	 ->
	 (?a2 my:cause ?a1),
	 (?a2 rdf:type my:DuplicateOfAct)
]

# Rule: DisplacedAct-Seq_error [mistake & sequence]
# ...

# Rule: NoFirstOfSequence-Seq_error [mistake & sequence]
# (-)

# Rule: TooEarlyInSequence-Seq_error [mistake & sequence]
[TooEarlyInSequence:
	(?b rdf:type my:WrongNext),
	(?b my:should_be ?correct_b),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st_b),

	(?p my:student_parent_of ?b),
	(?p my:executes ?bnd_p), (?bnd_p my:boundary_of ?seq),
	(?seq rdf:type my:sequence),
	(?seq my:body_item ?correct_b),
		(?correct_b my:item_index ?index_c),
		(?st_b my:item_index ?index_b),
		lessThan(?index_c, ?index_b),
	 ->
	 (?b my:should_be_after ?correct_b),
	 (?b rdf:type my:TooEarlyInSequence)
]

# Rule: TooLateInSequence-Seq_error [mistake & sequence]
[TooLateInSequence:
	(?b rdf:type my:WrongNext),
	(?a my:student_next ?b),

	(?p my:student_parent_of ?a),
	(?p my:student_parent_of ?b),
	(?p my:executes ?bnd_p), (?bnd_p my:boundary_of ?seq),
	(?seq rdf:type my:sequence),
	(?seq my:body_item ?st_a),
	(?seq my:body_item ?st_b),

	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?st_a),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st_b),
		(?st_a my:item_index ?index_a),
		(?st_b my:item_index ?index_b),
		greaterThan(?index_a, ?index_b),
	 ->
	 (?b my:should_be_before ?st_a),
	 (?b rdf:type my:TooLateInSequence)
]
# does not work good >
## Rule: TooLateInSequence-Seq_error [mistake & sequence]
#[
#	(?b rdf:type my:WrongNext),
#	(?b my:should_be ?correct_bnd), (?correct_bnd my:boundary_of ?correct_b),
#	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st_b),
#
#	(?p my:student_parent_of ?b),
#	(?p my:executes ?bnd_p), (?bnd_p my:boundary_of ?seq),
#	(?seq rdf:type my:sequence),
#
#		(?correct_b my:item_index ?index_c),
#		(?st_b my:item_index ?index_b),
#		greaterThan(?index_c, ?index_b),
#	 - > (?b my:should_be_after ?correct_b),
#	 (?b rdf:type my:TooLateInSequence)
#]



# [mistake & sequence & helper]
[_FindWhatChildrenExecute_Propagate1:
	(?par_b my:gather_child_exec_till ?par_e),
	noValue(?par_e my:gathered_child_exec_till ?par_e),
	(?child1_act my:gathered_child_exec_till ?par_e),
	(?child1_act my:student_next ?child2_act),
	(?par_b my:student_parent_of ?child2_act),
		(?child2_act my:student_index ?i1),
		(?par_e my:student_index ?i2),
		lessThan(?i1, ?i2),
	(?child2_act my:executes ?bound),
	 ->
	 (?par_b my:child_executes ?bound),
	 (?child2_act my:gathered_child_exec_till ?par_e),
]
# [mistake & sequence & helper]
[_FindWhatChildrenExecute_Propagate2:
	(?par_b my:gather_child_exec_till ?par_e),
	noValue(?par_e my:gathered_child_exec_till ?par_e),
	(?child1_act my:gathered_child_exec_till ?par_e),
	(?child1_act my:student_corresponding_end ?child2_act),
	(?par_b my:student_parent_of ?child2_act),
		(?child2_act my:student_index ?i1),
		(?par_e my:student_index ?i2),
		lessThan(?i1, ?i2),
	(?child2_act my:executes ?bound),
	 ->
	 (?par_b my:child_executes ?bound),
	 (?child2_act my:gathered_child_exec_till ?par_e),
]
# [mistake & sequence & helper]
[_FindWhatChildrenExecute_Finalize:
	(?par_b my:gather_child_exec_till ?par_e),
	noValue(?par_e my:gathered_child_exec_till ?par_e),
	(?child1_act my:gathered_child_exec_till ?par_e),
	(?child1_act my:student_next ?par_e),
	 ->
	 (?par_e my:gathered_child_exec_till ?par_e),
#	 remove gather_child_exec_till
	 drop(0)
]
# [mistake & sequence & helper]
[_FindWhatChildrenExecute_Cleanup:
	(?child_act my:gathered_child_exec_till ?par_e),
#	gathering completed
	(?par_b my:gather_child_exec_till ?par_e),
#	do not remove final mark
		(?child_act my:student_index ?i1),
		(?par_e my:student_index ?i2),
		lessThan(?i1, ?i2),
#	print("_FindWhatChildrenExecute_Cleanup", ?child_act)
	 ->
#	 remove gathered_child_exec_till
	 drop(0)
]


# Rule: SequenceFinishedTooEarly-init1-Seq_error [mistake & sequence]
[
	(?b rdf:type my:act_end),
	(?b my:executes ?seq_e),
	(?seq_e my:boundary_of ?seq),
	(?seq rdf:type my:sequence),

	(?a my:student_corresponding_end ?b),
	(?a my:student_parent_of ?child_act),
	(?child_act rdf:type my:TooEarlyInSequence),
#	print("SequenceFinishedTooEarly-init1", ?b),
	 ->
#	 find which children acts were executed till the end of seq
	 (?a my:gather_child_exec_till ?b),
]
# Rule: SequenceFinishedTooEarly-init2-Seq_error [mistake & sequence]
[
	(?b rdf:type my:act_end),
	(?b my:executes ?seq_e),
	(?seq_e my:boundary_of ?seq),
	(?seq rdf:type my:sequence),

	(?a my:student_corresponding_end ?b),
	(?b rdf:type my:Erroneous),
#	print("SequenceFinishedTooEarly-init2", ?b),
	 ->
#	 find which children acts were executed till the end of seq
	 (?a my:gather_child_exec_till ?b),
]
# Rule: SequenceFinishedTooEarly-finish-Seq_error [mistake & sequence]
[
	(?b rdf:type my:act_end),
	(?b my:executes ?seq_e), (?seq_e my:boundary_of ?seq),
	(?seq rdf:type my:sequence),

#	check that gathering completed
	(?a my:student_corresponding_end ?b),
	(?b my:gathered_child_exec_till ?b),
#	get a boundary of seq action (that was not executed)
	(?seq my:body_item ?some_st),
##	(?some_st_bnd my:boundary_of ?some_st),
	(?some_st_bnd my:begin_of ?some_st),
#	check that some bounds are not in gathered
	noValue(?a my:child_executes ?some_st_bnd),
#	print("SequenceFinishedTooEarly-finish", ?b),
	 ->
	 (?b my:should_be_after ?some_st),
	 (?b rdf:type my:SequenceFinishedTooEarly),
]


# Rule: SequenceFinishedNotInOrder-Seq_error [mistake & sequence]
[
	(?b rdf:type my:act_end),
	(?b my:executes ?seq_e), (?seq_e my:boundary_of ?seq),
	(?seq rdf:type my:sequence),

	(?st_b my:consequent ?seq_e),

	(?a my:student_next ?b),
	noValue(?a my:executes ?st_b),

	(?st_b my:boundary_of ?st),
	 ->
	 (?b my:should_be_after ?st),
	 (?b rdf:type my:SequenceFinishedNotInOrder),
]










###############################
# alternative mistake
###############################


# Rule: NoFirstCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_begin),
	(?a my:executes ?bnd), (?bnd my:begin_of ?alt),
	(?alt rdf:type my:alternative),

#	(?alt my:branches_item ?br),
#	(?br rdf:type my:first_item),
#	(?br my:cond ?cnd),

	(?a my:student_next ?b),
	(?b rdf:type my:WrongNext),
#		(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st_b),
#		(?cnd my:id ?i1),
#		(?st_b my:id ?i2),
#		notEqual(?i1, ?i2),
	 ->
#	 (?b my:precursor ?a),
	 (?b rdf:type my:NoFirstCondition)
]

### when different cond used
# Rule: ConditionTooEarly-atAltBegin-alt_Error [alternative & mistake]
[
	(?b rdf:type my:NoFirstCondition),
	(?b my:executes ?bnd), (?bnd my:begin_of ?cnd),

	(?br my:cond ?cnd),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?br my:item_index ?br_i),
	greaterThan(?br_i, 0),
	 ->
#	 (?b my:precursor ?a),
	 (?b rdf:type my:ConditionTooEarly)
]

# Rule: BranchOfFalseCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:expr_value "false"^^xsd:boolean),

	(?a my:executes ?bnd), (?bnd my:boundary_of ?cnd),
	(?cnd rdf:type my:expr),

	(?alt_act my:student_parent_of ?a),
	(?alt_act my:student_parent_of ?b),
	(?b rdf:type my:act_begin),

	(?br my:cond ?cnd),
#	(?br rdf:type my:alt_branch),
	(?alt my:branches_item ?br),

	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?br),
#	cond appears before the branch
	(?a my:student_index ?i1),
	(?b my:student_index ?i2),
	lessThan(?i1, ?i2),
	 ->
	 (?b my:should_be ?alt),
#	 (?b my:precursor ?a),
	 (?b my:cause ?a),
	 (?b rdf:type my:BranchOfFalseCondition)
]

## Rule: WrongBranch-alt_Error [alternative & mistake]
#[
#	(?a rdf:type my:act_begin),
#	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
#	(?alt my:branches_item ?br),
#	(?alt rdf:type my:alternative),
#
#	(?b rdf:type my:act_begin),
#	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?br2),
#	(?alt my:branches_item ?br2),
#		(?br my:id ?i),
#		(?br2 my:id ?i2),
#		notEqual(?i, ?i2),
## 	основывается на правильной трассе !!
#	(?alt_act my:parent_of ?a),
#	(?alt_act my:student_parent_of ?b),
#	 - > (?b my:should_be ?a),
#	 (?b my:precursor ?a),
#	 (?b rdf:type my:WrongBranch)
#]

# Rule: BranchWithoutCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_begin),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?b my:student_next ?a),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st),

	(?br my:cond ?cnd),

		(?st my:id ?i),
		(?cnd my:id ?i2),
		notEqual(?i, ?i2),
	 ->
	 (?a my:should_be_after ?cnd),
	 (?a my:precursor ?b),
	 (?a my:context_should_be ?alt),
	 (?a rdf:type my:BranchWithoutCondition)
]

# Rule: BranchNotNextToCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:BranchWithoutCondition),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
	(?br my:cond ?cnd),

	(?alt_act my:student_parent_of ?a),
	(?c my:executes ?bnd_b), (?bnd_b my:boundary_of ?cnd),
	(?a my:in_trace ?trace),
	(?c my:in_trace ?trace),
#	^ можно переделать на student_parent_of ??

		(?alt_act my:student_index ?ia),
		(?c my:student_index ?ic),
		lessThan(?ia, ?ic),

		(?a my:student_index ?ib),
		lessThan(?ic, ?ib),
	 ->
	 (?a rdf:type my:BranchNotNextToCondition)
]

# Rule: ElseBranchNotNextToLastCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_begin),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
	(?br rdf:type my:else),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?b my:student_next ?a),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st),

	(?br1 my:next ?br),
	(?br1 my:cond ?cnd),

		(?st my:id ?i),
		(?cnd my:id ?i2),
		notEqual(?i, ?i2),
	 ->
	 (?a my:should_be_after ?cnd),
	 (?a my:precursor ?b),
	 (?a my:context_should_be ?alt),
	 (?a rdf:type my:ElseBranchNotNextToLastCondition)
]

# Rule: ElseBranchAfterTrueCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_begin),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
	(?br rdf:type my:else),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?br1 my:next ?br),
	(?br1 my:cond ?cnd),

	(?b my:student_next ?a),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?cnd),

	(?b my:expr_value "true"^^xsd:boolean),

	 -> (?a my:should_be_after ?cnd),
	 (?a my:precursor ?b),
	 (?a my:context_should_be ?alt),
	 (?a rdf:type my:ElseBranchAfterTrueCondition)
]

# Rule: CondtionNotNextToPrevCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_begin),
	(?alt my:branches_item ?br2),
	(?alt rdf:type my:alternative),
	(?br2 my:cond ?cnd2),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd2),

	(?b my:student_next ?a),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st),

	(?br1 my:next ?br2),
	(?br1 my:cond ?cnd1),

		(?st my:id ?i),
		(?cnd1 my:id ?i2),
		notEqual(?i, ?i2),
	 ->
	 (?a my:should_be_after ?cnd1),
	 (?a my:precursor ?b),
	 (?a my:context_should_be ?alt),
	 (?a rdf:type my:CondtionNotNextToPrevCondition)
]

#	specify ^ as 2: the condition is too early/too late
# Rule: ConditionTooEarly-afterCond-alt_Error [alternative & mistake]
[
	(?a rdf:type my:CondtionNotNextToPrevCondition),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd2),
	(?br2 my:cond ?cnd2),
	(?alt my:branches_item ?br2),
	(?alt rdf:type my:alternative),

	(?b my:student_next ?a),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?cnd1),
	(?br1 my:cond ?cnd1),
	(?alt my:branches_item ?br1),

	(?br1 my:item_index ?br1_i),
	(?br2 my:item_index ?br2_i),
	greaterThan(?br2_i, ?br1_i),
	 ->
#	 (?a my:precursor ?b),
	 (?a rdf:type my:ConditionTooEarly)
]
# Rule: ConditionTooLate-alt_Error [alternative & mistake]
[
	(?a rdf:type my:CondtionNotNextToPrevCondition),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd2),
	(?br2 my:cond ?cnd2),
	(?alt my:branches_item ?br2),
	(?alt rdf:type my:alternative),

	(?b my:student_next ?a),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?cnd1),
	(?br1 my:cond ?cnd1),
	(?alt my:branches_item ?br1),

	(?br1 my:item_index ?br1_i),
	(?br2 my:item_index ?br2_i),
	lessThan(?br2_i, ?br1_i),
	 ->
#	 (?a my:precursor ?b),
	 (?a rdf:type my:ConditionTooLate)
]
# Rule: DuplicateOfCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:CondtionNotNextToPrevCondition),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd),
	(?br2 my:cond ?cnd),
	(?alt my:branches_item ?br2),
	(?alt rdf:type my:alternative),
#	not only next
	(?p my:student_parent_of ?a),
	(?p my:student_parent_of ?b),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?cnd),
#	later act only
	(?b my:student_index ?i1),
	(?a my:student_index ?i2),
	lessThan(?i1, ?i2),
	 ->
#	 (?a my:precursor ?b),
	 (?a rdf:type my:DuplicateOfCondition)
]

# Rule: ConditionAfterBranch-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?a my:student_next ?b),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?cnd),
	(?cnd rdf:type my:expr),

	 ->
	 (?b my:should_be ?alt),
#	 (?b my:precursor ?a),
	 (?b rdf:type my:ConditionAfterBranch)
]

# Rule: AnotherExtraBranch-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_begin),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?b rdf:type my:act_begin),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?br2),
	(?alt my:branches_item ?br2),

	(?alt_act my:student_parent_of ?a),
	(?alt_act my:student_parent_of ?b),

	(?a my:student_index ?sia),
	(?b my:student_index ?sib),
	greaterThan(?sib, ?sia),
	 ->
	 (?b my:cause ?a),
	 (?b rdf:type my:AnotherExtraBranch)
]

# Rule: NoBranchWhenConditionIsTrue-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd),
	(?cnd rdf:type my:expr),

	(?a my:expr_value "true"^^xsd:boolean),

	(?br my:cond ?cnd),
	(?br rdf:type my:alt_branch),

	(?a my:student_next ?b),
#	(?b rdf:type my:WrongNext),
	(?b my:executes ?bnd_b),
	noValue(?bnd_b my:boundary_of ?br),
#		(?st my:id ?i),
#		(?br my:id ?i2),
#		notEqual(?i, ?i2),
	 ->
	 (?b my:should_be ?br),
#	 (?b my:precursor ?a),
	 (?b rdf:type my:NoBranchWhenConditionIsTrue)
]

# Rule: LastConditionIsFalseButNoElse-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd),
	(?cnd rdf:type my:expr),
	(?a my:expr_value "false"^^xsd:boolean),

	(?br my:cond ?cnd),
	(?br my:next ?br2),
	(?br2 rdf:type my:else),

	(?a my:student_next ?b),
	(?b rdf:type my:WrongNext),
#	(?b my:executes ?st),
#		(?st my:id ?i),
#		(?br2 my:id ?i2),
#		notEqual(?i, ?i2),
	 ->
	 (?b my:should_be ?br2),
#	 (?b my:precursor ?a),
	 (?b rdf:type my:LastConditionIsFalseButNoElse)
]

# Rule: NoNextCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd),
	(?cnd rdf:type my:expr),

	(?a my:expr_value "false"^^xsd:boolean),
	(?br my:cond ?cnd),
	(?br my:next ?br2),
	(?br2 my:cond ?cnd2),

	(?a my:student_next ?b),
	(?b rdf:type my:WrongNext),

#	(?b my:executes ?st),
#		(?st my:id ?i),
#		(?cnd2 my:id ?i2),
#		notEqual(?i, ?i2),
	 ->
	 (?b my:should_be ?cnd2),
#	 (?b my:precursor ?a),
	 (?b rdf:type my:NoNextCondition)
]

# Rule: LastFalseNoEnd-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_end),
	(?cnd rdf:type my:expr),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd),

	(?a my:expr_value "false"^^xsd:boolean),
	(?br my:cond ?cnd),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),
	(?br rdf:type my:last_item),

	(?a my:student_next ?b),
	(?b rdf:type my:WrongNext),
#	(?b my:executes ?st),
#		(?st my:id ?i),
#		(?alt my:id ?i2),
#		notEqual(?i, ?i2),
	 ->
	 (?b my:precursor ?a),
#	 (?b my:should_be ?alt),
	 (?b rdf:type my:LastFalseNoEnd)
]

# Rule: NoAlternativeEndAfterBranch-alt_Error [alternative & mistake]
[

	(?a rdf:type my:act_end),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?br),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?a my:student_next ?b),
	(?b rdf:type my:WrongNext),
#	(?b my:executes ?st),
#		(?st my:id ?i),
#		(?alt my:id ?i2),
#		notEqual(?i, ?i2),
	 ->
	 (?b my:should_be ?alt),
#	 (?b my:precursor ?a),
	 (?b rdf:type my:NoAlternativeEndAfterBranch)
]

# Rule: AlternativeEndAfterTrueCondition-alt_Error [alternative & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:expr_value "true"^^xsd:boolean),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?cnd),
	(?br my:cond ?cnd),
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),

	(?a my:student_next ?b),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?alt),
	 ->
	 (?b my:should_be ?br),
	 (?b my:precursor ?a),
	 (?b rdf:type my:AlternativeEndAfterTrueCondition)
]








###############################
# loop mistake
###############################

# Rule: LoopStartIsNotCondition-loop_Error [loop & mistake]
[
	(?a rdf:type my:act_begin),
	(?a my:executes ?bnd), (?bnd my:boundary_of ?Loop),
	(?Loop rdf:type my:start_with_cond),
	(?Loop my:cond ?cnd),

	(?a my:student_next ?b),
	(?b my:executes ?bnd_b),
#	not loop end
	noValue(?bnd_b my:boundary_of ?Loop),
#	not loop's cond
	noValue(?bnd_b my:boundary_of ?cnd),
	 ->
#	 (?b my:cause ?a),
	 (?b rdf:type my:LoopStartIsNotCondition)
]

# Rule: LoopStartIsNotIteration-loop_Error [loop & mistake]
[
	(?a rdf:type my:act_begin),
	(?a my:executes ?bnd), (?bnd my:boundary_of ?Loop),
	(?Loop rdf:type my:start_with_body),
	(?Loop my:body ?Body),

	(?a my:student_next ?b),
	(?b my:executes ?bnd_b),
#	not loop end
	noValue(?bnd_b my:boundary_of ?Loop),
#	not loop's body
	noValue(?bnd_b my:boundary_of ?Body),
	 ->
#	 (?b my:cause ?a),
	 (?b rdf:type my:LoopStartIsNotIteration)
]

# Rule: NoIterationAfterSuccessfulCondition-1-loop_Error [loop & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:executes ?bnd), (?bnd my:boundary_of ?cnd),
	(?Loop my:cond ?cnd),
	(?Loop rdf:type my:cond_then_body),

	(?a my:expr_value "true"^^xsd:boolean),

	(?a my:student_next ?b),
	(?Loop my:body ?Body),
	(?b my:executes ?bnd_b),
	noValue(?bnd_b my:boundary_of ?Body),
	 ->
#	 (?b my:cause ?a),
	 (?b rdf:type my:NoIterationAfterSuccessfulCondition)
]

# Rule: LoopEndAfterSuccessfulCondition-1-loop_Error [loop & mistake]
[
	(?a rdf:type my:act_end),
	(?a my:executes ?bnd), (?bnd my:boundary_of ?cnd),
	(?Loop my:cond ?cnd),
	(?Loop rdf:type my:cond_then_body),

	(?a my:expr_value "true"^^xsd:boolean),

	(?a my:student_next ?b),
	(?b my:executes ?bnd_b),
	(?bnd_b my:end_of ?Loop),
	 ->
#	 (?b my:cause ?a),
	 (?b rdf:type my:LoopEndAfterSuccessfulCondition)
]

# Rule: NoIterationAfterSuccessfulCondition-0-loop_Error [loop & mistake]
# ...

# Rule: NoLoopEndAfterFailedCondition-0-loop_Error [loop & mistake]
[
	(?a rdf:type my:act_end),
	(?Loop rdf:type my:loop),
	(?Loop my:cond ?cnd),
	(?a my:executes ?bnd), (?bnd my:boundary_of ?cnd),

	(?a my:expr_value "false"^^xsd:boolean),

	(?a my:student_next ?b),
	(?b rdf:type my:WrongNext),
	 ->
#	 (?b my:cause ?a),
	 (?b rdf:type my:NoLoopEndAfterFailedCondition)
]

# Rule: LoopEndsWithoutCondition-loop_Error [loop & mistake]
[
	(?b rdf:type my:act_end),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?Loop),
	(?Loop rdf:type my:conditional_loop),

	(?a my:student_next ?b),
#	(?b rdf:type my:Erroneous),
	(?Loop my:cond ?cnd),
	(?a my:executes ?bnd_a),
	noValue(?bnd_a my:boundary_of ?cnd),
	 ->
	 (?b rdf:type my:LoopEndsWithoutCondition)
]

# Rule: LoopContinuedAfterFailedCondition-loop_Error [loop & mistake]
[
	(?b rdf:type my:NoLoopEndAfterFailedCondition),
	(?b rdf:type my:ConditionMisuse),
	 -> (?b rdf:type my:LoopContinuedAfterFailedCondition)
]

# Rule: IterationAfterFailedCondition-loop_Error [loop & mistake]
[
	(?b rdf:type my:NoLoopEndAfterFailedCondition),
	(?b rdf:type my:act_begin),
	(?b my:executes ?bnd), (?bnd my:boundary_of ?st),
	(?L my:body ?st),
	(?L rdf:type my:cond_then_body),
	 -> (?b rdf:type my:IterationAfterFailedCondition)
]

# Rule: NoConditionAfterIteration-loop_Error [loop & mistake]
[
	(?a rdf:type my:act_end),
	(?Loop rdf:type my:body_then_cond),
	(?Loop my:body ?st),
	(?a my:executes ?bnd), (?bnd my:boundary_of ?st),
	(?Loop my:cond ?cnd),

	(?a my:student_next ?b),
	(?b my:executes ?bnd_b),
	noValue(?bnd_b my:boundary_of ?cnd),
	 ->
	 (?b rdf:type my:NoConditionAfterIteration)
]

# Rule: NoConditionBetweenIterations-loop_Error [loop & mistake]
[
	(?a rdf:type my:act_end),
	(?Loop rdf:type my:body_then_cond),
	(?Loop my:body ?st),
	(?a my:executes ?bnd_a), (?bnd_a my:boundary_of ?st),

	(?a my:student_next ?b),
	(?b rdf:type my:act_begin),
	(?b my:executes ?bnd_b), (?bnd_b my:boundary_of ?st),
#	страховка >
#	(?b rdf:type my:Erroneous),
	(?Loop my:cond ?cnd),
	 ->
	 (?b my:should_be_after ?cnd),
	 (?b rdf:type my:NoConditionBetweenIterations)
]


