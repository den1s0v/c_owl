@prefix  rdf:      <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix  rdfs:     <http://www.w3.org/2000/01/rdf-schema#> .


# An important RDF rules subset
@include <jena/rdfs4core.rules>.

@include <jena/loop_names.ttl>.

# @include <RDFS>.

@prefix my: <http://vstu.ru/poas/code#> .

# # Converted from SWRL
# @include <from_swrl.jena_rules> .

# `rdf:type` нельзя заменить на `a`, как в turtle


# java -jar jena/Jena.jar jena "test_data/ajax.rdf" "jena/test_native.ttl" "test_data/jena_output.rdf"
# java -jar jena/Jena.jar jena "test_data/jena_test.ttl" "jena/test_native.ttl" "test_data/jena_output.n3"
# java -jar jena/Jena.jar jena "jena_in.rdf" "jena/test_native.ttl" "test_data/jena_output.n3"
# java -jar jena/Jena.jar jena "jena_in.rdf" "jena/test_native.ttl;jena/test_native_trace.ttl" "test_data/jena_output.n3"



###############################
# action-boundaries-polyfill
###############################

[action-boundary-polyfill-begin_of:
	(?a rdf:type my:action),
	noValue(?x my:begin_of ?a) ,

	makeSkolem(?b, ?a, "begin_of"),
	 ->
	 (?b rdf:type my:boundary) ,
	 (?b my:begin_of ?a) ,
]

[action-boundary-polyfill-end_of:
	(?a rdf:type my:action),
	noValue(?x my:end_of ?a) ,

	makeSkolem(?b, ?a, "end_of"),
	 ->
	 (?b rdf:type my:boundary) ,
	 (?b my:end_of ?a) ,
]

# this two ^ rules work good.



###############################
# stmt and expr
###############################


[connect_StmtEnd:

	(?st rdf:type my:stmt),
	(?b my:begin_of ?st),
	(?e my:end_of ?st),
	 ->
	 (?b my:always_consequent ?e),
	 (?b my:StmtEnd ?e),
]
[connect_ExprEnd:

	(?st rdf:type my:expr),
	(?b my:begin_of ?st),
	(?e my:end_of ?st),
	 ->
	 (?b my:always_consequent ?e),
	 (?b my:ExprEnd ?e),
]



###############################
# helper
###############################


[branches_item-o-cond-to-parent_of:

	(?a my:branches_item ?b),
	(?b my:cond ?c)
	 -> (?a my:parent_of ?c)
]

[loop-cond-to-parent_of:

	(?Loop rdf:type my:loop),
	(?Loop my:cond ?c)
	 -> (?Loop my:parent_of ?c)
]

##[normal_consequent_to_verbose-a-a:

##	(?x rdf:type my:action),
##	(?y rdf:type my:action),
##	(?x my:normal_consequent ?y),
##	(?ex my:end_of ?x),
##	(?by my:begin_of ?y),

##	 ->
##	 (?ex my:verbose_consequent ?by),
##]
##
##[normal_consequent_to_verbose-a-b:

##	(?x rdf:type my:action),
##	(?y rdf:type my:boundary),
##	(?x my:normal_consequent ?y),
##	(?ex my:end_of ?x),
###	(?by my:begin_of ?y),

##	 ->
##	 (?ex my:verbose_consequent ?y),
##]
##
##[normal_consequent_to_verbose-e-a:

##	(?x rdf:type my:boundary),
##	(?y rdf:type my:action),
##	(?x my:normal_consequent ?y),
#	(?ex my:end_of ?x),
##	(?by my:begin_of ?y),

##	 ->
##	 (?x my:verbose_consequent ?by),
##]
##
##[normal_consequent_to_verbose-e-b:

##	(?x rdf:type my:boundary),
##	(?y rdf:type my:boundary),
##	(?x my:normal_consequent ?y),
##	 ->
##	 (?x my:verbose_consequent ?y),
##]



[attach-principal_violation-to-possible_violation-at-reason_node:

	(?R my:reason_kind ?reason),
	(?reason my:principal_violation ?viol)
	 -> (?R my:possible_violation ?viol)
]



###############################
# entry_point and sequence
###############################


[start__to__GlobalCode__rule_g4:

#	print("Entry point is ..."),
	(?alg my:entry_point ?gc ),
	(?gc rdf:type my:sequence ),
	(?b my:begin_of ?gc),

	 ->
	 (?alg my:always_consequent ?b),
	 (?alg my:GlobalCodeBegin ?b),
]

[connect_SequenceBegin_rule_g2:

	(?block rdf:type my:sequence),
	(?b my:begin_of ?block),

	(?block my:body_item ?st),
	(?st rdf:type my:first_item),
	(?b2 my:begin_of ?st),

	makeSkolem(?R, ?b, ?b2),
	(?block my:stmt_name ?seq_name),
	(?st my:stmt_name ?inner_name),
	 ->
	 (?b my:always_consequent ?b2),
	 (?b my:SequenceBegin ?b2),
	  (?R my:reason_kind my:SequenceBegin),
	  (?b my:to_reason ?R), (?R my:from_reason ?b2),
	  (?R my:field_SEQ ?seq_name),
	  (?R my:field_INNER ?inner_name),
]

[connect_SequenceNext:

	(?block rdf:type my:sequence),
	(?block my:body_item ?st),
	(?st my:next ?st2),
	(?e my:end_of ?st),
	(?b my:begin_of ?st2),

	makeSkolem(?R, ?e, ?b),
	(?block my:stmt_name ?seq_name),
	(?st my:stmt_name ?previous_name),
	(?st2 my:stmt_name ?next_name),
	 ->
	 (?e my:always_consequent ?b),
	 (?e my:SequenceNext ?b),
	  (?R my:reason_kind my:SequenceNext),
	  (?e my:to_reason ?R), (?R my:from_reason ?b),
	  (?R my:field_SEQ ?seq_name),
	  (?R my:field_PREVIOUS ?previous_name),
	  (?R my:field_NEXT ?next_name),
]

[connect_SequenceEnd:

	(?block rdf:type my:sequence),
	(?e my:end_of ?block),
	(?block my:body_item ?st),
	(?st rdf:type my:last_item),
	(?e1 my:end_of ?st),

	makeSkolem(?R, ?e1, ?e),
	(?block my:stmt_name ?seq_name),
	 ->
	 (?e1 my:always_consequent ?e),
	 (?e1 my:SequenceEnd ?e),
	  (?R my:reason_kind my:SequenceEnd),
	  (?e1 my:to_reason ?R), (?R my:from_reason ?e),
	  (?R my:field_SEQ ?seq_name),
]






###############################
# alternative
###############################


[connect_AltBegin:

	(?alt rdf:type my:alternative),
	(?b my:begin_of ?alt),
	(?alt my:branches_item ?br),
	(?br rdf:type my:first_item),

	(?br my:cond ?cnd),
	(?b2 my:begin_of ?cnd),

	makeSkolem(?R, ?b, ?b2),
	(?alt my:stmt_name ?alt_name),
	(?cnd my:stmt_name ?cnd_name),
	 ->
	 (?b my:always_consequent ?b2),
	 (?b my:AltBegin ?b2),
	  (?R my:reason_kind my:AltBegin),
	  (?b my:to_reason ?R), (?R my:from_reason ?b2),
	  (?R my:field_ALT ?alt_name),
	  (?R my:field_ALT_COND ?cnd_name),
]

[connect_AltBranchBegin_CondTrue:
	(?cnd rdf:type my:expr),

#	(?a my:expr_value "true"^^xsd:boolean),
	(?br my:cond ?cnd),
	(?br rdf:type my:alt_branch),

	(?e my:end_of ?cnd),
	(?b my:begin_of ?br),

	makeSkolem(?R, ?e, ?b),
#	(?alt my:stmt_name ?alt_name),
	(?cnd my:stmt_name ?cnd_name),
	(?br my:stmt_name ?branch_name),
	 ->
	 (?e my:on_true_consequent ?b),
	 (?e my:AltBranchBegin ?b),
	  (?R my:reason_kind my:AltBranchBegin),
	  (?e my:to_reason ?R), (?R my:from_reason ?b),
#	  (?R my:field_ALT ?alt_name),
	  (?R my:field_ALT_COND ?cnd_name),
	  (?R my:field_BRANCH ?branch_name),
]


[attach-possible_violation-for-AltBranchBegin:
	(?R my:reason_kind my:AltBranchBegin),
	(?e my:to_reason ?R),
	(?e my:to_reason ?R2),
#	another way leads to ELSE branch => the branch exists in the Alternative.
	(?R2 my:reason_kind my:AltElseBranchBegin),
	 ->
	 (?R my:possible_violation my:ElseBranchAfterTrueCondition)
]


[connect_NextAltCondition:
	(?cnd rdf:type my:expr),

#	(?a my:expr_value "false"^^xsd:boolean),

	(?br my:cond ?cnd),
	(?br rdf:type my:alt_branch),

	(?br my:next ?br2),
	(?br2 my:cond ?cnd2),

	(?e my:end_of ?cnd),
	(?b my:begin_of ?cnd2),

	makeSkolem(?R, ?e, ?b),
	(?cnd my:stmt_name ?cnd_name),
	(?cnd2 my:stmt_name ?cnd2_name),
	 ->
	 (?e my:on_false_consequent ?b),
	 (?e my:NextAltCondition ?b),
	  (?R my:reason_kind my:NextAltCondition),
	  (?e my:to_reason ?R), (?R my:from_reason ?b),
	  (?R my:field_ALT_COND ?cnd_name),
	  (?R my:field_NEXT_COND ?cnd2_name),
]

[connect_AltElseBranch:
	(?cnd rdf:type my:expr),

#	(?a my:expr_value "false"^^xsd:boolean),

	(?br my:cond ?cnd),
	(?br rdf:type my:alt_branch),
	(?alt my:branches_item ?br),

	(?br my:next ?br2),
	(?br2 rdf:type my:else),

	(?e my:end_of ?cnd),
	(?b my:begin_of ?br2),

	makeSkolem(?R, ?e, ?b),
	(?alt my:stmt_name ?alt_name),
	(?cnd my:stmt_name ?cnd_name),
	 ->
	 (?e my:on_false_consequent ?b),
	 (?e my:AltElseBranchBegin ?b),
	  (?R my:reason_kind my:AltElseBranchBegin),
	  (?e my:to_reason ?R), (?R my:from_reason ?b),
	  (?R my:field_ALT ?alt_name),
	  (?R my:field_ALT_COND ?cnd_name),
]

[connect_AltEndAllFalse:
	(?cnd rdf:type my:expr),

#	(?a my:expr_value "false"^^xsd:boolean),

	(?br my:cond ?cnd),
	(?br rdf:type my:alt_branch),
	(?alt my:branches_item ?br),

	(?br rdf:type my:last_item),
	(?alt rdf:type my:alternative),
	(?e my:end_of ?alt),

	(?e1 my:end_of ?cnd),

	makeSkolem(?R, ?e1, ?e),
	(?alt my:stmt_name ?alt_name),
	 ->
	 (?e1 my:on_false_consequent ?e),
	 (?e1 my:AltEndAllFalse ?e),
	  (?R my:reason_kind my:AltEndAllFalse),
	  (?e1 my:to_reason ?R), (?R my:from_reason ?e),
	  (?R my:field_ALT ?alt_name),
]

[connect_AltEndAfterBranch:
	(?alt my:branches_item ?br),
	(?alt rdf:type my:alternative),
	(?e my:end_of ?alt),

	(?e1 my:end_of ?br),

	makeSkolem(?R, ?e1, ?e),
	(?alt my:stmt_name ?alt_name),
	 ->
	 (?e1 my:always_consequent ?e),
	 (?e1 my:AltEndAfterBranch ?e),
	  (?R my:reason_kind my:AltEndAfterBranch),
	  (?e1 my:to_reason ?R), (?R my:from_reason ?e),
	  (?R my:field_ALT ?alt_name),
]




###############################
# loop
###############################

[connect_LoopBegin-cond:
	(?Loop rdf:type my:start_with_cond),
	(?Loop my:cond ?cnd),
	(?b my:begin_of ?Loop),

	(?b2 my:begin_of ?cnd),

	makeSkolem(?R, ?b, ?b2),
	(?Loop my:stmt_name ?loop_name),
	(?cnd my:stmt_name ?cnd_name),
	 ->
	 (?b my:always_consequent ?b2),
	 (?b my:PreCondLoopBegin ?b2),
	  (?R my:reason_kind my:PreCondLoopBegin),
	  (?b my:to_reason ?R), (?R my:from_reason ?b2),
	  (?R my:field_LOOP ?loop_name),
	  (?R my:field_LOOP_COND ?cnd_name),
]

[connect_LoopBegin-body:
	(?Loop rdf:type my:start_with_body),
	(?Loop my:body ?st),
	(?b my:begin_of ?Loop),

	makeSkolem(?R, ?b, ?b2),
	(?Loop my:stmt_name ?loop_name),
	(?b2 my:begin_of ?st),
	 ->
	 (?b my:always_consequent ?b2),
	 (?b my:PostCondLoopBegin ?b2),
	  (?R my:reason_kind my:PostCondLoopBegin),
	  (?b my:to_reason ?R), (?R my:from_reason ?b2),
	  (?R my:field_LOOP ?loop_name),
]

[connect_LoopCond1-BodyBegin:
	(?Loop rdf:type my:cond_then_body),
	(?Loop my:cond ?cnd),
	(?Loop my:body ?st),

	(?e my:end_of ?cnd),
	(?b my:begin_of ?st),

	makeSkolem(?R, ?e, ?b),
	(?Loop my:stmt_name ?loop_name),
	(?cnd my:stmt_name ?cnd_name),
	 ->
	 (?e my:on_true_consequent ?b),
	 (?e my:IterationBeginOnTrueCond ?b),
	  (?R my:reason_kind my:IterationBeginOnTrueCond),
	  (?e my:to_reason ?R), (?R my:from_reason ?b),
	  (?R my:fetch_kind_of_loop ?Loop),
	  (?R my:field_LOOP ?loop_name),
	  (?R my:field_LOOP_COND ?cnd_name),
]

# Rule: connect_LoopCond0-body [correct & loop]
# ...

[connect_LoopCond1-update:
	(?Loop rdf:type my:pre_update_loop),
	(?Loop my:cond ?cnd),
	(?Loop my:update ?upd),

	(?e my:end_of ?cnd),
	(?b my:begin_of ?upd),
	 ->
	 (?e my:on_true_consequent ?b),
	 (?e my:LoopUpdateOnTrueCond ?b),
]

[connect_LoopUpdate-body:
	(?Loop rdf:type my:pre_update_loop),
	(?Loop my:update ?upd),
	(?Loop my:body ?st),

	(?e my:end_of ?upd),
	(?b my:begin_of ?st),
	 ->
	 (?e my:always_consequent ?b),
	 (?e my:IterationAfterUpdate ?b),
]

[connect_LoopCond0-LoopEnd:
	(?Loop rdf:type my:conditional_loop),
	(?Loop my:cond ?cnd),
	(?e my:end_of ?Loop),

	(?e1 my:end_of ?cnd),

	makeSkolem(?R, ?e1, ?e),
	(?Loop my:stmt_name ?loop_name),
	(?cnd my:stmt_name ?cnd_name),
	 ->
	 (?e1 my:on_false_consequent ?e),
	 (?e1 my:LoopEndOnFalseCond ?e),
	  (?R my:reason_kind my:LoopEndOnFalseCond),
	  (?e1 my:to_reason ?R), (?R my:from_reason ?e),
	  (?R my:fetch_kind_of_loop ?Loop),
	  (?R my:field_LOOP ?loop_name),
	  (?R my:field_LOOP_COND ?cnd_name),
]


# Rule: connect_LoopCond1-LoopEnd [correct & loop]
# ...

[connect_LoopBody-cond:
	(?Loop rdf:type my:body_then_cond),
	(?Loop my:body ?st),
	(?Loop my:cond ?cnd),

	(?e my:end_of ?st),
	(?b my:begin_of ?cnd),

	makeSkolem(?R, ?e, ?b),
	(?Loop my:stmt_name ?loop_name),
	(?cnd my:stmt_name ?cnd_name),
	 ->
	 (?e my:always_consequent ?b),
	 (?e my:LoopCondBeginAfterIteration ?b),
	  (?R my:reason_kind my:LoopCondBeginAfterIteration),
	  (?e my:to_reason ?R), (?R my:from_reason ?b),
	  (?R my:field_LOOP ?loop_name),
	  (?R my:field_LOOP_COND ?cnd_name),
]

[connect_LoopBegin-init:
	(?Loop rdf:type my:start_with_init),
	(?Loop my:init ?st),
	(?b my:begin_of ?Loop),

	(?b2 my:begin_of ?st),
	 ->
	 (?b my:always_consequent ?b2),
	 (?b my:LoopWithInitBegin ?b2),
]

[connect_LoopInit-cond:
	(?Loop rdf:type my:start_with_init),
	(?Loop my:init ?st),
	(?Loop my:cond ?cnd),

	(?e my:end_of ?st),
	(?b my:begin_of ?cnd),
	 ->
	 (?e my:always_consequent ?b),
	 (?e my:LoopCondBeginAfterInit ?b),
]

[connect_LoopBody-update:
	(?Loop rdf:type my:post_update_loop),
	(?Loop my:body ?st),
	(?Loop my:update ?upd),

	(?e my:end_of ?st),
	(?b my:begin_of ?upd),
	 ->
	 (?e my:always_consequent ?b),
	 (?e my:LoopUpdateAfterIteration ?b),
]

[connect_LoopUpdate-cond:
	(?Loop rdf:type my:post_update_loop),
	(?Loop my:update ?upd),
	(?Loop my:cond ?cnd),

	(?e my:end_of ?upd),
	(?b my:begin_of ?cnd),
	 ->
	 (?e my:always_consequent ?b),
	 (?e my:LoopCondAfterUpdate ?b),
]

